{% import "views/_helper.njk" as docs %}
{% import "views/_data.njk" as data %}
{% import "views/_sms.njk" as sms %}
{% import "views/_parts.html" as include %}
{% set middot = 'Â·' %}
{% set app_permission_link = "[Dashboard > Data > Settings > User Account](/dashboard/storage.html?appid={{appid}}#/storage/conf)" %}
{% set query_result_limit = "The number of records returned by each query is limited to 100 by default. To change the limit, please refer to [Limiting Query Results](#limiting)." %}

# LeanStorage {{platform_name}} Guide

{{productName}} is a core feature offered by LeanCloud that allows your app to persist and query data in the cloud. Here we will walk you through the basic usage of it with a quick example.

The code below creates an object with Class `Todo` and stores it into the cloud:

{% block code_quick_save_a_todo %}{% endblock %}

If you already have experience with relational database, you will notice that {{productName}} is quite different from it. {{productName}} adopts a schema-free data structure, which means that the schema of the database doesn't have to be set up in advance, and new properties can be added into an existing object at any time. If you need to add `location` into the same Todo object as a new property, simply make the following change:

{% block code_quick_save_a_todo_with_location %}{% endblock %}

- The SDK designed for each language interacts with the same [REST API](rest-api.html) via HTTPS, offering fully functional interfaces for you to manipulate the data in the cloud.

The main differences between {{productName}} and traditional databases (like MySQL, Postgres, and MongoDB) are:

1. Traditional databases are server-oriented which require developers to build their own server-side programs and authenticate with usernames and passwords. App developers need to implement security features by themselves and write interfaces for clients to interact with databases. {{productName}} is client-oriented instead, which offers fully functional API-level permission management with ACL. Developers could embed {{productName}} SDK directly in their clients for accessing data and don't have to implement server-side programs anymore.
2. Comparing to relational databases (like MySQL and Postgres), {{productName}} provides weaker support for joining tables or transactions, which means that certain amount of redundancy would be required for some types of apps. However, the extensibility of the database would be highly improved, which allows applications to handle more requests.

Below we will introduce the two data types supported by {{productName}}:

* Objects
* Files

## SDK Installation

The JavaScript SDK supports Chrome 45+, recent versions of Firefox, IE 10+, Edge, iOS 9.3+, Android 4.4+, WeApp DevTools, Node.js 4.0+, React Native 0.26+, and Electron.

### npm

The easiest way to integrate our JavaScript SDK in your project is to use npm:

```bash
$ npm install leancloud-storage --save
```

Then include it with require:

```js
// Include SDK
var AV = require('leancloud-storage');
var { Query, User } = AV;
// Initialize SDK
AV.init('APP_ID', 'APP_KEY');
```

### CDN

You may also use a pre-compiled SDK file in your webpage with the following `<script>` tag:

```html
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@{{jssdkversion}}/dist/av-min.js"></script>
```

And then create references to the SDK:

```js
// Include SDK
var { Query, User } = AV;
// Initialize SDK
AV.init('APP_ID', 'APP_KEY');
```

### Additional SDK Setup

Check out our Github repo https://github.com/leancloud/javascript-sdk/releases for more releases and file formats.

If you plan to use our JavaScript SDK in Android WebView, please check out [WebView](#webview) section of this guide.

If you plan to use [LiveQuery](#livequery), include the following npm module instead:

```js
// No need to require 'leancloud-storage' if the following line is present
var AV = require('leancloud-storage/live-query');
```

Or load it with the following `<script>` tag: 

```html
<!-- No need to load av-min.js if the following script is present -->
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@{{jssdkversion}}/dist/av-live-query-min.js"></script>
```

You also need to go to your app's [LeanCloud Dashboard > Storage > Settings page](/dashboard/storage.html?appid={{appid}}#/storage/conf) and check on the **Enable LiveQuery** option under the **Misc** section before you can expect it to work.

### Initializing Your Application

Go to your app's [LeanCloud Dashboard setting page](/dashboard/app.html?appid={{appid}}#/key) and look for your App ID and App Key, then copy and paste them into your initialization code:

```js
var APP_ID  = '{{appId}}';
var APP_KEY = '{{appKey}}';

// Same as using AV.init('APP_ID', 'APP_KEY')
AV.init({
  appId:  APP_ID,
  appKey: APP_KEY,
  region: 'us' // Defaults to China if not specified
});
```

Apps running on LeanCloud are region-specific, which means that no data will be communicated across regions. Therefore, incorrect region settings will cause the initialization to fail.

Each region has its own REST APIs. Please refer to the following documentations for the correct URL schemes of APIs to be used:

- Docs for US region: https://us.leancloud.cn/docs/rest_api.html.
- Docs for China region: https://leancloud.cn/docs/rest_api.html. 

{% block text_web_security %}{% endblock %}

## Debug Logs

You can easily trace the problems in your application by turning debug logs on during the development phase. Once enabled, details of every request made by the SDK along with errors will be output to IDE, browser console, or [LeanEngine logs](/dashboard/cloud.html?appid={{appid}}#/log) in LeanCloud Dashboard.

```js
// In Node.js, set environment variable DEBUG=leancloud*
// Debug logs will be enabled when running app with npm
DEBUG=leancloud* npm start

// If using Node.js with LeanEngine, go to LeanCloud Dashboard > LeanEngine > Settings > Custom Environment Variables
// Put DEBUG in the first field and leancloud:* in the second field (make sure to include the colon between leancloud and *)
DEBUG=leancloud:* lean up

// Set localStorage in browser console
localStorage.setItem('debug', 'leancloud*');

// Enable debug logs for LiveQuery
localStorage.setItem('debug', 'LC*');
```

{% call docs.alertWrap() %}
Make sure debug logs are turned off before your app is published. Failure to do so may lead to the exposure of sensitive data.
{% endcall %}

## Objects

`{{baseObjectName}}` is {{productName}}'s encapsulation of high-level objects, with each of them containing a number of property-value pairs (or key-value pairs). The value of properties are JSON-compatible. When storing data through REST API, the data is encoded with JSON. The data is schema free, meaning that you don't need to specify the keys of an object in advance. Simply set whatever key-value pairs you need for an object, and our backend will handle the rest for you.

### Data Types

`{{baseObjectName}}` supports the following data types:

{% block code_data_type %}{% endblock %}

Keep in mind that our backend stores dates in UTC and the SDK will convert them to local times upon retrieval.

### Creating Objects

The code below creates a new instance of `{{baseObjectName}}`:

{% block code_create_todo_object %}{% endblock %}

Each {{objectIdName}} must have a Class name so that the cloud knows which table it belongs to.

{{ docs.alert(data.classNameConvention()) }}

### Saving Objects

Now we are going to save a `TodoFolder` containing multiple Todos. We don't need to create a Class named **TodoFolder** in advance. The cloud will automatically create the Class when the following code is executed:

{% block code_save_todo_folder %}{% endblock %}

After running the code, you should be able to see the data you just created within Class **TodoFolder** at [Dashboard > Data](/data.html?appid={{appid}}#/). Beside the name and priority we just specified, you will see some other built-in properties as well:

Built-in Property | Type | Description
--- | --- | ---
`objectId` | {{ "str" if segment_code == "python" else "String"}} | A unique identifier for each saved object.
`ACL` | {{ "leancloud.ACL" if segment_code == "python" else "ACL"}} | Access Control List, a JSON-compatible data defining the read and write permissions of other people.
`{{createdAtName}}` | {{dateType}} | The time the object was created.
`{{updatedAtName}}` | {{dateType}} | The time the object was last modified.

<dl>
  <dt>Property Name</dt>
  <dd>Also called key, which contains only alphanumeric strings and underscores.</br>Custom property names {{ docs.alertInline("cannot begin with double underscores `__` or be any of the following system reserved property names") }}.</dd>
    <div class="callout callout-danger monospace" style="margin-top:1em;color:#999;">{{ data.preservedWords() }}</div>
  </dd>
  <dt>Property Value</dt>
  <dd>Can be string, number, boolean, array, or dictionary.</dd>
</dl>

We recommend that you adopt CamelCase naming convention to `NameYourClassesLikeThis` and `nameYourKeysLikeThis`, which keeps your code more readable.

#### Saving Objects with CQL

{{productName}} offers a method that allows you to save an object with the syntax similar to using INSERT in SQL. The following code saves a TodoFolder object into the cloud:

{% block code_save_object_by_cql %}{% endblock %}

#### Saving Options

The following options can be appended when saving `{{baseObjectName}}`:

Option | Type | Available for | Description
--- | --- | --- | ---
{{ docs.nowrap(saveOptions_fetchWhenSave) }} | Boolean | create<br/>update | Return the latest value of the object after saving it. `create` returns all the properties of the object; `update` returns the updated properties only. See [Updating Counters](#updating-counters) for more details.
`{{saveOptions_query}}` | {{baseQueryClassName}}  | update | Only when the conditions in `query` are satisfied will the object be updated, otherwise the object will not be updated and error code 305 will be returned.<br/><br/>Conditions specified in `query` work only for existing objects. It will not work if you are saving a new object.<br/><br/>You could have used `{{baseQueryClassName}}` and `{{baseObjectName}}` to perform such operation, but the operation would not be done atomically. Using such option eliminates the potential conflicts that could occur when multiple users are trying to update the same object at the same time. See [Updating Data Conditionally](#updating-data-conditionally) for more details.

### Retrieving Objects

Each object stored in the cloud is assigned with a unique `{{objectIdName}}` which can be used to retrieve it:

{{ code_get_todo_by_objectId() }}

Beside using `{{baseQueryClassName}}`, you may also construct a new `{{baseObjectName}}` and fetch data with it using objectId:

{% block code_fetch_todo_by_objectId %}{% endblock %}

#### Retrieving Object IDs

Each time when an object is saved to the cloud, its `{{objectIdName}}` will be returned which is a unique global identifier of the object.

{% block code_save_callback_get_objectId %}{% endblock %}

#### Retrieving Properties

The following code shows how you can get the properties of a Todo object:

{% block code_access_todo_folder_properties %}{% endblock %}

Notice how special properties `{{objectIdName}}`, `{{createdAtName}}`, and `{{updatedAtName}}` are fetched in a different way.

If you attempt to access a property that does not exist, the SDK will not throw an error but will return a null instead.

#### Default Properties

Each object stored in the cloud has three default properties: `{{objectIdName}}`, `{{createdAtName}}`, and `{{updatedAtName}}`.

<dl>
  <dt>`{{createdAtName}}`</dt>
  <dd>The time when the object is first saved to the cloud. Once the time is generated, it will not be changed anymore.</dd>
  <dt>`{{updatedAtName}}`</dt>
  <dd>The last time when the object is updated.</dd>
</dl>

{{ data.localizedDates() }}

#### Refreshing Objects

When the same object is shared across multiple clients, you may refresh the version stored in any one of them to make sure that it is synchronized with the version in the cloud:

{% block code_object_fetch %}{% endblock %}

After the object is refreshed, its local `{{updatedAtName}}` property will be refreshed as well. The cloud wouldn't have the latest value of `{{updatedAtName}}` until the next save operation is done, thus some network bandwidth can be saved.

#### Refreshing Specific Properties

Todo has 4 custom properties: `priority`, `content`, `location`, and `title`. The following code will refresh `priority` and `location` only:

{% block code_object_fetch_with_keys %}{% endblock %}

Keep in mind that **refreshing will overwrite the local properties with those in the cloud**. Any unsaved changes made to the object prior to the operation will be discarded.

### Updating Objects

{{productName}} determines whether an object should be created or updated based on <u>the existence of objectId</u>. If the objectId exists, the object associated with it will be updated, otherwise a new object will be created.

If the `{{objectIdName}}` of an object is already known, you can construct `{{baseObjectName}}` locally for updating the object:

{% block code_update_todo_content_with_objectId %}{% endblock %}

The data in the cloud will be updated based on the last request sent to the cloud. Only fields with updates will be changed and those without updates will remain intact.

#### Updating Data Conditionally

Using `query` in [Saving Options](#saving-options) allows you to update an object based on certain conditions. Only when conditions are met will the object be updated.

For example, the Class `Account` has a field named `balance` which multiple requests are updating at the same time. Since an account cannot have a negative balance, only when **balance >= the requested value** will the request take effect, otherwise "Insufficient balance. Operation failed!" will be printed.

{% block code_saveoption_query_example %}{% endblock %}

#### Updating Objects with CQL

{{productName}} offers a method that allows you to update an object with the syntax similar to using UPDATE in SQL. The following code updates a TodoFolder object in the cloud:

{% block code_update_object_by_cql %}{% endblock %}

#### Updating Counters

This is one of the atomic operations supported by {{productName}}. It allows you to increase or decrease a field with number atomically. Take Twitter as an example, we need to keep track of how many Likes and Retweets a tweet has gained so far, but multiple Likes or Retweets can happen simultaneously since there are multiple clients. If each client reads the data it fetched from the cloud and then writes the updated data into the cloud, potential conflicts could occur which leads to inaccurate data. To solve the problem, atomic operations should be used for updating counters.

To keep track of the times a shared Todo is viewed, use the following code:

{% block code_atomic_operation_increment %}{% endblock %}

#### Updating Arrays

Updating array is also an atomic operation. The following operations allow you to update a field with array:

- `{{baseObjectName}}.add('arrayKey', value)`<br/>appends the given object to the end of an array.
- `{{baseObjectName}}.addUnique('arrayKey', value)`<br/>adds the given object into an array only if it is not in it. The position inserted is not guaranteed.
- `{{baseObjectName}}.remove('arrayKey', value)`<br/>removes all instances of the given object from an array.

For example, Todo has a field named `reminders` which is an array containing all the times when a user wants to be alerted. The following code adds 7:10, 7:20, and 7:30 into it:

{% block code_set_array_value %}{% endblock %}

### Deleting Objects

The following code deletes a Todo object in the cloud:

{% block code_delete_todo_by_objectId %}{% endblock %}

{% call docs.alertWrap() %}
Object deletion is a sensitive operation and the permission for deleting objects is turned off by default. See [ACL Guide](acl-guide.html) for more details.
{% endcall %}

#### Deleting Objects with CQL

{{productName}} offers a method that allows you to delete an object with the syntax similar to using DELETE in SQL. The following code deletes a Todo object in the cloud:

{% block code_delete_todo_by_cql %}{% endblock %}

### Batch Processing

You can create, save, delete, or fetch multiple objects within a single request:

{% block code_batch_operation %}{% endblock %}

Set all Todos to be completed:

{% block code_batch_set_todo_completed %}{% endblock %}

`saveAll` and `fetchAll` send as many requests behind the scene as the number of objects in the collection, while `deleteAll` completes everything in a single network request. {# TODO: Please refer to the [Calculation of API Calls](faq.html#calculation-of-api-calls) for more details. #}

### Relational Data

#### Pointers

Now we have a public space where users can share their TodoFolders with others and those who see them can leave comments under them. Assuming there is a user who shared the list of games he wants to buy (his TodoFolder contains a list of game names), we can store likes and comments from other users within a Comment object:

{% block code_pointer_comment_one_to_many_todoFolder %}{% endblock %}

##### Retrieving Objects in Pointers

With TodoFolder as a Pointer property of Todo, we can retrieve the TodoFolder together with Todo using the following code:

{% block code_pointer_include_todoFolder %}{% endblock %}

#### GeoPoints

{{productName}} uses `{{geoPointObjectName}}` for storing and querying geographical locations.

The code below creates `{{geoPointObjectName}}` with 39.9 as latitude and 116.4 as longitude (LeanCloud Beijing Office):

{% block code_create_geoPoint %}{% endblock %}

The code below assigns a GeoPoint to a Todo reflecting the location the Todo is created:

{% block code_use_geoPoint %}{% endblock %}

See also [Queries on GeoPoints](#queries-on-geopoints).

### Data Models

Objects may have relationships with other objects. For example, in a blogging application, a Post object may have many Comment objects. LeanCloud supports three kinds of relationships, including one-to-one, one-to-many, and many-to-many.

#### One-to-One and One-to-Many Relationships

One-to-one and one-to-many relationships are modeled by saving `{{baseObjectName}}` as a value in the other object. For example, each Comment in a blogging app might correspond to one Post.

The following code creates a new Post with a single Comment:

```js
// Declare classes
var Post    = {{baseObjectName}}.extend('Post');
var Comment = {{baseObjectName}}.extend('Comment');

// Create a post
var post = new Post();
post.set('title', 'I am starving!');
post.set('content', 'Hmmm, where should I go for lunch?');

// Create a comment
var comment = new Comment();
comment.set('content', 'KFC is the best!');

// Add the post as a value of the comment
comment.set('parent', post);

// This will save both post and comment
comment.save();
```

Internally, the backend will store the referred-to object with the Pointer type in just one place in order to maintain consistency. You can also link objects using their objectIds like this:

```js
var post = new Post();
post.id = '5aedba542f301e437093bda5';

comment.set('parent', post);
```

When an object is fetched, the related {{baseObjectName}}s of it will not be fetched unless they are explicitly specified:

```js
var commentQuery = new AV.Query('Comment');
commentQuery.first().then(function (comment) {
  var parentPost = comment.get('parent');
  parentPost.fetch({
    success: function (post) {
      var title = post.get('title');
    }
  });
});
```

More examples can be found in the [Query](#relational-queries) portion of this guide.

#### Many-to-Many Relationships

The easiest way to model many-to-many relationships is to use Arrays. In most cases, using Arrays helps you reduce the number of queries you need to make and leads to a better performance. However, if additional properties need to be attached to the relationships between two Classes, using Join Tables would be a better choice. Keep in mind that the additional properties are used to describe the relationships between Classes rather than any single Class.

We recommend you to use Join Tables if the total amount of objects of any Class exceeds 100.

{% call docs.noteWrap() %}
Modeling relationships among data could be a tough work. We have written a dedicated article to address [Data Modeling](data-modeling.html) in greater detail, which we highly recommend you reading.
{% endcall %}

### Data Protocol

You might be wondering how types of data sent from clients are identified by the cloud. Here we are going to introduce the data protocol used by {{productName}}.

Let's take a date as an example. In {{platform_name}}, the default type of date is `{{dateType}}`. The following code sets a property of `{{baseObjectName}}` to be `{{dateType}}` and saves the object to the cloud:

{% block code_data_protocol_save_date %}{% endblock %}

Before {{sdk_name}} saves the object to the cloud, it automatically serializes the data by converting `{{dateType}}` to the following format:

```json
{
  "__type": "Date",
  "iso": "2015-11-21T18:02:52.249Z"
}
```

After the cloud receives the data, it automatically deserializes it so that the data could be identified as a date. The table below shows the serialized formats of some types of data:

Type | Serialized Format
---|---
`{{dateType}}` | `{"__type": "Date", "iso": "2015-11-21T18:02:52.249Z"}`
`{{byteType}}` | `{"__type": "Bytes", "base64": "utf-8-encoded-string"}`
`Pointer` | `{"__type": "Pointer", "className": "Todo", "objectId": "55a39634e4b0ed48f0c1845c"}`
`{{relationObjectName}}` | `{"__type": "Relation", "className": "Todo"}`

## Files

Beside objects mentioned above, files like images, music, and videos can be stored as well. Some developers also choose to serialize complicated objects into JSON or XML and store them as files. File storage in {{productName}} is encapsulated into `{{fileObjectName}}` which offers operations including file upload and file download.

### Uploading Files

By uploading a file, you store it into the cloud and get a URL pointing to it.

A new entry will be generated in the `_File` table after a file is uploaded. **You cannot modify the entry after it has been generated**, including data in [metaData field](#file-metadata). If you need to change the file, you have to upload the modified file again and a new id and URL will be generated.

The entry can be deleted only if the [delete permission](#deleting-files) of `_File` is enabled.

#### Creating Files from Data Streams

`{{fileObjectName}}` supports files with common types like images, videos, and music, including any binary data. The following code constructs a file by taking in a data stream:

{% block code_create_avfile_by_stream_data %}{% endblock %}

The file is named `resume.txt`. Keep in mind that:

- Each file being uploaded will get its unique ID, so it is allowed for multiple files to share the same name.
- A correct extension needs to be assigned to each file which the cloud will use to infer the type of a file. For example, if you are storing a PNG picture with `{{fileObjectName}}`, use `.png` as its extension.

#### Creating Files from Local Paths

Many apps interact with file systems of devices and the most common interaction is to read local files. The following code creates `{{fileObjectName}}` from a local file:

{% block code_create_avfile_from_local_path %}{% endblock %}

#### Creating Files from URLs

Many apps need to create files from URLs as well. The following code stores a image from the internet to the cloud:

{% block code_create_avfile_from_url %}{% endblock %}

[Creating Files from Local Paths](#creating-files-from-local-paths) will <u>lead to actual traffic for uploading files</u> and the files will be stored into the cloud. [Creating Files from URLs](#creating-files-from-urls) will not upload the actual files into the cloud but will store the addresses of the files as strings.

{% block text_upload_file %}{% endblock %}

#### Progress Listener

You can improve the user experience of uploading process by showing the progress of it:

{% block code_upload_file_with_progress %}{% endblock %}

### Image Thumbnails

You can get the thumbnail of an image without downloading the entire file:

{% block code_file_image_thumbnail %}{% endblock %}

<div class="callout callout-info">Thumbnails cannot be generated for files larger than **20 MB**.</div>

<div class="callout callout-danger">Thumbnails are currently only available for apps in the North China region.</div>

### File Metadata

The `metaData` of `{{fileObjectName}}` can be used to store the metadata of this file object. metaData **cannot be modified** once stored to the cloud.

{% block code_file_metadata %}{% endblock %}

{# 2017-11-09 the following block doesn't apply to swift, php, python #}
{% if segment_code === 'objc' or segment_code === 'java' or segment_code === 'js' or segment_code === 'android' %}
### Referencing Files

The following code creates a reference from AVObject's field to `AVFile` with `Pointer`:

{% block file_as_avatar %}{% endblock %}

Make sure to `include` the field when querying:

{% block query_file_as_avatar %}{% endblock %}
{% endif %}

{% block text_file_query %}{% endblock %}

### Deleting Files

To delete a file in the cloud:

<div class="callout callout-danger">By default, a file is not allowed to be deleted. You can change the setting by going to [Dashboard > Data > **`_File`**](/data.html?appid={{appid}}#/_File) and select **Misc** > **Permission Settings** > **delete**.</div>

{% block code_file_delete %}{% endblock %}

{% block code_cache_operations_file %}{% endblock %}

### Enabling HTTPS

If you demand that the files in the cloud should be accessed through HTTPS, check on **Enable HTTPS domain** in [Dashboard > Data > Settings > Files](/dashboard/storage.html?appid={{appid}}#/storage/conf). There is no free quota on using HTTPS for files and you will see the pricing once the function is enabled.

{{ docs.alert("By enabling HTTPS, whether the URLs of the files returned by API use HTTPS or HTTP will be affected. Keep in mind that even the function is not enabled, the clients can still access files with HTTPS URLs which will lead to additional expenditure.") }}

After enabling HTTPS, the URLs of the files previously stored in the `_File` table will be converted to HTTPS. If you disable the function, the URLs being converted will not change back.

LeanCloud RTM stores files sent through messages with `AVFile` and the URLs of the files will be included in the messages. After HTTPS is enabled, the URLs of the files sent in the past messages will not be automatically converted.

{% block text_http_access_for_ios9andup %}{% endblock %}

### Custom Domains

LeanCloud offers a shared domain for all the apps to access the files stored in the cloud. However, due to the Cyber Security Law of the countries where we offer our services, the shared domain might not be available all the time. We highly recommend that you **set up your custom domains for accessing files** so that your apps will not be affected when the shared domain becomes unavailable. You can set up custom domains at [Storage > Settings > Files](/dashboard/storage.html?appid={{appid}}#/storage/conf).

### CDN Support

{{ data.cdn(true) }}

## Queries

`{{baseQueryClassName}}` is the basic Class for constructing queries on `{{baseObjectName}}`. {{query_result_limit}}

### Sample Data Structure

Familiarizing yourself with the data structure mentioned here will help you better understand the material we will be covering later.

![](images/todo-schema.svg)

#### Todo (Todo Item)

| Field | Type | Description |
| :-- | :-- | :-- |
| `content` | String | The content of the todo. |
| `images` | AVFile | Images related to the todo. |
| `location` | String | The location where the todo takes place. |
| `priority` | Number | 0 indicates the highest priority. |
| `reminders` | Array | Dates and times of reminders. |
| `status` | Number | 0 is incomplete; 1 is completed. |
| `title` | String | The title of the todo. |
| `views` | Number | The times the todo has been viewed. |
| `whereCreated` | AVGeoPoint | The location where the todo is created. |

#### TodoFolder (Folder of Todo Items)

| Field | Type | Description |
| :-- | :-- | :-- |
| `containedTodos` | Relation | Todo items contained in the folder which has relationship with `Todo` table. |
| `name` | String | The name of the folder, like "Family" or "Meeting". |
| `owner` | Pointer | The owner of the folder which points to a `_User`. |
| `priority` | Number | 0 indicates the highest priority. |
| `tags` | Relation | Has relationship with `Tag` table. |

#### Comment (Comment to a Folder)

| Field | Type | Description |
| :-- | :-- | :-- |
| `content` | String | The content of the comment. |
| `likes` | Number | 1 is like; -1 is dislike; 0 by default. |
| `targetTodoFolder` | Pointer | Points to a `TodoFolder`. |

#### Tag (Tag for a Folder)

| Field | Type | Description |
| :-- | :-- | :-- |
| `name` | String | The name of the tag, like "Today", "Urgent", "Important", etc. |
| `targetTodoFolder` | Pointer | Points to a `TodoFolder`. |

### Creating Queries

{% block code_create_query_by_className %}{% endblock %}

A basic usage of query is to look up an object with its objectId:

{{ code_get_todo_by_objectId() }}

### Query Constraints

{% block table_logic_comparison_in_query %}{% endblock %}

With the logical operations mentioned above, a query with constraints can be easily created.

For example, if you are looking for all the Todo items with priority less than 2:

{% block code_query_lessThan %}{% endblock %}

<div class="callout callout-info">{{query_result_limit}}</div>

The logic above can be rewritten in SQL to be `select * from Todo where priority < 2`, and {{productName}} allows you to use such syntax for querying as well. For more details, refer to [Querying with CQL](#querying-with-cql).

To look for all the Todo items with priority greater than or equal to 2:

{% block code_query_greaterThanOrEqualTo %}{% endblock %}

#### Multiple Constraints

Query constraints are AND'd by default, which means that the results of a query will satisfy all the constraints specified. [Compound Queries](#compound-queries) should be used if you expect them to be OR'd.

In a **basic query**, if multiple conditions are assigned to the **same property** of an object, only the last assignment will take effect. For example, if you are looking for Todo items with priority to be either 0 or 1, the code below will not work:

{% block code_priority_equalTo_zero_and_one_wrong_example %}{% endblock %}

The correct way to implement such function is to use [Compound Queries > OR'd Queries](#or-d-queries).

### Queries on Strings

**Prefix query** works similarly as `LIKE 'keyword%'` in SQL. We have enabled indexing to make it efficient for large datasets as well.

{% block code_query_whereHasPrefix %}{% endblock %}

**Include query** works similarly as `LIKE '%keyword%'` in SQL. The following code looks for all the Todos containing "Tony":

{% block code_query_with_contains_keyword %}{% endblock %}

To query all the Todos that **do not include** "ticket" in their titles, you can use **regular expressions**:

{% block code_query_with_not_contains_keyword_using_regex %}{% endblock %}

<div class="callout callout-info">Queries with regular expressions **only work for** strings.</div>

There are two drawbacks of querying with regular expressions:

- The efficiency of querying will reduce with more data being entered into the dataset.
- The results will not be sorted based on text correlation.

Therefore, we don't recommend you relying on regular expressions to implement searching functions for your app. Instead, you should use [In-App Searching](#in-app-searching) which is based on search engine technology and offers a better performance.

### Queries on Arrays

There are various of ways for you to query a piece of data stored in an array as a property of an object. When we were talking about [Arrays](#updating-arrays), we have set `reminders` for each Todo which contains a number of dates. To look for all the Todos with 8:30 in their `reminders`:

{% block code_query_array_contains_using_equalsTo %}{% endblock %}

To look for those with 8:30 and 9:30 in their `reminders`:

{% block code_query_array_contains_all %}{% endblock %}

So far we have been writing queries to find the objects with arrays containing certain objects. If we have a Todo with 8:30, 9:30, and 10:30 in its `reminders`, it will be found out by the query above as well.

To look for those who do not contain certain objects:

{% block code_query_with_not_contains_keyword %}{% endblock %}

### Queries on Existences

Assuming that users are allowed to attach a picture to each Todo, the following code looks for all the Todos with pictures:

{% block code_query_where_keys_exist %}{% endblock %}

### Relational Queries

Similar to traditional databases, we offer interfaces for you to perform relational queries as well.

There are multiple ways for you to store relational data with {{productName}}. Below we will introduce the query methods that could be used for each of them.

#### Queries on Pointers

From what we discussed in [Pointers](#pointers), each Comment is associated with a TodoFolder indicating which TodoFolder it belongs to. The following code looks for all the Comments associated with a given TodoFolder:

{% block code_query_comment_by_todoFolder %}{% endblock %}

#### Queries on Relational Properties

When querying Comments, if you wish to fetch the TodoFolder associated with each Comment together without extra queries, you may call the `include` method on the query constructed for Comments. You can even write something like `include(b.c)` so that the AVUser associated with each TodoFolder can be fetched within the same query as well:

{% block code_query_comment_include_todoFolder %}{% endblock %}

If an object has an Array field `todoArray` containing a number of Pointers:

```
[pointer1, pointer2, pointer3]
```

It is possible to fetch these pointers themselves using `include`:

```objc
[query includeKey:@"todoArray"];
```
```java
query.include("todoArray");
```
```js
query.include('todoArray');
```

However, further queries with `include(b.c)` will not be supported.

Relational operations with dot `.` can be used with `select` as well:

```objc
[query selectKeys:@"targetTodoFolder.targetAVUser.username"];
```
```java
query.selectKeys(Arrays.asList("targetTodoFolder.targetAVUser.username"));
```
```js
query.select(['targetTodoFolder.targetAVUser.username']);
```

#### Inner Queries

With inner queries, it is possible to write a single query to look for all the Comments associated with TodoFolders who gained more than 20 likes. To do so, construct a query for [Comment](#comment-comment-to-a-folder-) like this:

{% block code_query_comment_match_query_todoFolder %}{% endblock %}

Keep in mind that each inner query returns at most 100 records by default (same as basic queries). To change the limit, please refer to [Limiting Query Results](#limiting).

**If the outer queries are not returning any records, the entire query will return zero records as well.** For example:

{{ data.innerQueryLimitation(description="", skip="[skip](#skipping)") }}

### Queries on GeoPoints

A common usage of querying GeoPoints is to find out the spots within a certain distance from a given point (like the phone itself). {{productName}} offers various of ways for querying GeoPoints.

#### Queries on GeoPoints Nearby

The `whereCreated` property of a Todo is `{{geoPointObjectName}}` object containing the location the Todo is created. The following code looks for all the Todos with `whereCreated` near a given location:

{% block code_query_geoPoint_near %}{% endblock %}

#### Queries on GeoPoints within a Scope

`whereWithinKilometers`, `whereWithinMiles`, or `whereWithinRadians` can be used for querying object within a scope.

The following code looks for all the Todos created within 2 kilometers:

{% block code_query_geoPoint_within %}{% endblock %}

#### Restrictions on GeoPoints

- Each `{{baseObjectName}}` can only hold a single `{{geoPointObjectName}}` property.
- The latitude of a GeoPoint should be within `-90.0` to `90.0` and the longitude should be within `-180.0` to `180.0`. An error will be raised if the data entered is out of scope.

### Compound Queries

A compound query is a single query consisting of multiple query conditions being connected with certain logical operations. The query conditions can be either OR'd or AND'd.

#### OR'd Queries

An object will be returned as long as it fulfills any one of the sub queries. The following code looks for all Todos with priority larger than or equal to 3, or status equal to 1 (completed):

{% block code_query_with_or %}{% endblock %}

**Queries regarding GeoPoints cannot be present among OR'd queries.**

#### AND'd Queries

An object will be returned only if it fulfills all the sub queries. The following code looks for all Todos created between `2016-11-13` and `2016-12-02`:

{% block code_query_with_and %}{% endblock %}

Constraints can be added to a new `{{baseQueryClassName}}` and such constraints will be AND'd.

### Counting and Sorting

#### Retrieving the First Object

Sometimes you may only need the first object from the results of a query. The following code retrieves the first Todo fulfilling the query:

{% block code_query_find_first_object %}{% endblock %}

#### Limiting

There is a `limit` to the amount of results being returned which is 100 by default. This means that even if there are 10,000 objects fulfilling the query, only 100 of them will be returned. The `limit` of a query could be any integer between 1 and 1,000. The code below returns at most 10 results for a query:

{% block code_set_query_limit %}{% endblock %}

#### Skipping

`skip` can be used on a query to skip certain number of results. You can implement pagination on your app by using `skip` together with `limit`. The code below returns the objects on the 3rd page, with 10 objects per page:

{% block code_set_skip_for_pager %}{% endblock %}

The method used here would demonstrate a relatively lower efficiency if you use it on large datasets. **We highly recommend you using `{{createdAtName}}` or `{{updatedAtName}}` to avoid potential performance issues.**

#### Retrieving Specific Properties

When retrieving an object, you can specify the properties you need for it if you are not using all of them, which reduces the data being transferred and improves the speed of query. The code below retrieves only the title and content of each Todo:

{% block code_query_select_keys %}{% endblock %}

You can even specify a property within a Pointer. The code below retrieves only the username of each Todo's owner (which is a Pointer):

{% block code_query_select_pointer_keys %}{% endblock %}

#### Counting

Sometimes you may wish to display a summary for a query like "1,020 results found". The code below prints out the number of Todos that are completed:

{% block code_query_count %}{% endblock %}

#### Sorting

You can sort numbers, strings, or dates in ascending or descending order:

{% block code_query_orderby %}{% endblock %}

You can even attach multiple sorting rules to a single query. The code below sorts Todos in ascending order by priority and descending order by createdAt:

{% block code_query_orderby_on_multiple_keys %}{% endblock %}

### Querying with CQL

If you have experience with SQL, you may write queries in CQL which is a syntax that allows you to write SQL-like commands for querying with {{productName}}.

The following code looks for all the Todos with status = 1 and the amount of Todos with priority = 0:

{% block code_query_by_cql %}{% endblock %}

You also have the option to pass variables as parameters into queries, just like how you can use a PreparedStatement in Java JDBC.

The following code looks for all the Todos with status = 0 and priority = 1:

{% block code_query_by_cql_with_placeholder %}{% endblock %}

### Optimizing Performance

There are several factors that could lead to potential performance issues when you conduct a query, especially when more than 100,000 records are returned at a time. We are listing some common ones here so you can design your apps accordingly to avoid them:

- Querying with "not equal to" or "not include" (index will not work)
- Querying on strings with a wildcard at the beginning of the pattern (index will not work)
- Using `count` with conditions (all the entries will be gone through)
- Using `skip` for a great number of entries (all the entries that need to be skipped will be gone through)
- Sorting without index (querying and sorting cannot share a composite index unless the conditions used on them are both covered by the same one)
- Querying without index (the conditions used on the query cannot share a composite index unless all of them are covered by the same one; additional time will be consumed if excessive data falls under the uncovered conditions)

## LiveQuery

Below are the scenarios in which you might consider using LiveQuery:

- Synchronizing data across multiple clients.
- Displaying data in real time.
- Two-way binding of data between cloud and client.

The video here shows the effect of using LiveQuery on the web client and the mobile client of the same app:

<div style="border:2px solid #ccc; margin-bottom:1em;">
  <video src="https://lc-lhzo7z96.cn-n1.lcfile.com/1496988080458" controls autoplay muted preload="auto" width="100%" height="100%">
    HTML5 Video is required for this demo.
  </video>
</div>

Feel free to try it by yourself with the following steps:

1. Scan the QR code below with WeChat to open the "LeanTodo" mini program:<br/>
   <img src="images/leantodo-weapp-qr.png" width="150" height="150"> 
2. Click on **Settings** > **Account Settings** on the bottom left of the screen, then create an account with a username and a password. You will need the same username and password later.
3. Visit <https://leancloud.github.io/leantodo-vue/> in your browser and enter the same credentials, then click on **Login**.
4. Enter some random data on one client and observe how changes are synchronized to other clients.

{{ docs.note("Make sure to create your account in the mini program first. If you create your account in the web app, you cannot log in to the same account in the mini program.") }}

### Setting up LiveQuery

Before you start setting up LiveQuery with SDK, go to [Dashboard > Data > Settings > Misc](/dashboard/storage.html?appid={{appid}}#/storage/conf) and check on "Enable LiveQuery". The SDK will throw an error if the function is not enabled in your dashboard.

```objc
// LiveQuery depends on the RTM module which you can find more information here:
// https://leancloud.cn/docs/sdk_setup-objc.html
// Add pod 'AVOSCloudLiveQuery' in Podfile and run `pod install`
[AVOSCloud setApplicationId:@"{{appid}}"
                  clientKey:@"{{appkey}}"];
```
```swift
AVOSCloud.setApplicationId("{{appid}}", clientKey: "{{appkey}}")
```
```java
// LiveQuery depends on the RTM module and the following content needs to be included in AndroidManifest.xml:
<!-- For the RTM module, Push Notifications, and LiveQuery START -->
<!-- The RTM module and Push Notifications depend on PushService -->
<service android:name="com.avos.avoscloud.PushService"/>
<receiver android:name="com.avos.avoscloud.AVBroadcastReceiver">
  <intent-filter>
    <action android:name="android.intent.action.BOOT_COMPLETED"/>
    <action android:name="android.intent.action.USER_PRESENT"/>
    <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
  </intent-filter>
</receiver>
<!-- For the RTM module, Push Notifications, and LiveQuery END -->

// Initialization
AVOSCloud.initialize(this,"{{appid}}","{{appkey}}");
```
```js
// If used in CommonJS (like Node.js or Webpack):
var AV = require('leancloud-storage/live-query');

// If used in a webpage with a <script> tag, use av-live-query-min.js:
// You may use our CDN:
// <script src="//cdn.jsdelivr.net/npm/leancloud-storage@{{jssdkversion}}/dist/av-live-query-min.js"></script>
```
```cs
// LiveQuery depends on the RTM module which you can find more information here:
// C# SDK Installation Guide: https://leancloud.cn/docs/sdk_setup-dotnet.html#_NET_Framework
// Unity SDK Installation Guide: https://leancloud.cn/docs/sdk_setup-dotnet.html#Mono_for_Unity
 
string appId = "{{appid}}";
string appKey = "{{appkey}}";
Websockets.Net.WebsocketConnection.Link();
var realtime = new AVRealtime(appId, appKey);
AVRealtime.WebSocketLog(Console.WriteLine);
AVClient.HttpLog(Console.WriteLine);
```

### Creating Basic Queries

Data is synchronized with LiveQuery based on the conditions specified for AVQuery. The instruction below shows how you can build a Todo app that allows data to be synchronized to the mobile app when a Todo is marked as completed.

The first thing you need to do is to create two queries on Todo, one for uncompleted items and one for completed ones:

```objc
AVQuery *doingQuery = [AVQuery queryWithClassName:@"Todo"];
AVQuery *doneQuery  = [AVQuery queryWithClassName:@"Todo"];
[doingQuery whereKey:@"state" equalTo:@"doing"];
[doneQuery  whereKey:@"state" equalTo:@"done"];
```
```swift
let doingQuery = AVQuery(className: "Todo")
let doneQuery = AVQuery(className: "Todo")

doingQuery.whereKey("state", equalTo: "doing")
doneQuery.whereKey("state", equalTo: "done")
```
```java
// Uncompleted Todos
AVQuery<AVObject> doingQuery = new AVQuery<>("Todo");
doingQuery.whereEqualTo("state", "doing");

// Completed Todos
AVQuery<AVObject> doneQuery = new AVQuery<>("Todo");
doneQuery.whereEqualTo("state", "done");
```
```js
// Uncompleted Todos
var doingQuery = new AV.Query('Todo').equalTo('state', 'doing');
// Completed Todos
var doneQuery = new AV.Query('Todo').equalTo('state', 'done');
```
```cs
// Uncompleted Todos
var doingQuery = new AVQuery<AVObject>("Todo").WhereEqualTo("state", "doing");
// Completed Todos
var doneQuery = new AVQuery<AVObject>("Todo").WhereEqualTo("state", "done");
```

### Retrieving Initial Data

The client needs to retrieve the data proactively when the page is first opened:

```objc
[doingQuery findObjectsInBackgroundWithBlock:^(NSArray * _Nullable objects, NSError * _Nullable error) {
  /* Uncompleted list did fetch. */
}];
```
```swift
let doingQuery = AVQuery(className: "Todo")

doingQuery.whereKey("state", equalTo: "doing")

doingQuery.findObjectsInBackground { objects, error in
  /* Uncompleted list did fetch. */
}
```
```java
AVQuery<AVObject> doingQuery = new AVQuery<>("Todo");
doingQuery.whereEqualTo("state", "doing");
doingQuery.findInBackground(new FindCallback<AVObject>() {
  @Override
  public void done(List<AVObject> parseObjects, AVException parseException) {
    // Todos fulfilling the query
  }
});
```
```js
doingQuery.find().then(function (doingList) {
  // Display `doingList`
});
```
```cs
// Assuming `doingList` to be the data a list object is binded to
var doingList = new List<AVObject>();
var doing = await doingQuery.FindAsync();
doingList = doing.ToList();
```

### Subscribing to Changes

When using LiveQuery, what you basically do is to define a query and subscribe to all the changes happening to the objects that fulfill the query. In the previous example, if we need to change a Todo named "Buy power bank" from uncompleted to completed, we need to:

1. Remove "Buy power bank" from "Uncompleted".
2. Add "Buy power bank" into "Completed".

If we implement such function without LiveQuery, we need to have the client fetch data from the cloud periodically or have the user refresh the page on their own. With LiveQuery, data can be synchronized automatically when changes happen in the cloud.

```objc
/* Import LiveQuery module */
#import <AVOSCloudLiveQuery/AVOSCloudLiveQuery.h>

self.doingLiveQuery = [[AVLiveQuery alloc] initWithQuery:doingQuery];
self.doingLiveQuery.delegate = self;
[self.doingLiveQuery subscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
  /* Subscribed. */
}];
#pragma mark - LiveQuery delegate methods
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidCreate:(id)object {
  if (liveQuery == self.doingLiveQuery) {
    /* A new doing task did create. */
  }
}
```
```swift
func subscribe() {
  let doingQuery = AVQuery(className: "Todo")
  doingQuery.whereKey("state", equalTo: "doing")

  let doingLiveQuery = AVLiveQuery(query: doingQuery)

  doingLiveQuery.delegate = self
  doingLiveQuery.subscribe { (succeeded, error) in
    /* Subscribed. */
  }
}

func liveQuery(_ liveQuery: AVLiveQuery, objectDidCreate object: Any) {
  /* A new doing task did create. */
}
```
```java
AVLiveQuery doingLiveQuery = AVLiveQuery.initWithQuery(doingQuery);
doingLiveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void done(AVLiveQuery.EventType eventType, AVObject avObject, List<String> updateKeyList) {
    // Callback function for new events
  }
});
doingLiveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Subscribed
    }
  }
});
```
```js
doingQuery.subscribe().then(function (subscription) {
  subscription.on('create', function (newDoingItem) {
    // Add `newDoingItem` into `doingList`
  });
});
```
```cs
var livequery = await doingQuery.SubscribeAsync();
livequery.OnLiveQueryReceived += (sender, e) => 
{
  if(e.Scope == "create")
  {
    doingList.Add(e.Payload);
  }
};
```

The main purpose of the code above is to subscribe:

```objc
[self.doingLiveQuery subscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
  /* Subscribed. */
}];
```
```swift
doingLiveQuery.subscribe { (succeeded, error) in
  /* Subscribed. */
}
```
```java
doingLiveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Subscribed
    }
  }
});
```
```js
doingQuery.subscribe().then(function (subscription) {
  // `subscription` is the subscription of `doingQuery`
});
```
```cs
var livequery = await doingQuery.SubscribeAsync();
```

The following types of data changes can be listened once subscription is set up:

- `create`: a new object is created and it fulfills the query.
- `update`: an existing object which fulfills the query is updated.
- `enter`: an existing object's old value does not fulfill the query but its new value fulfills the query.
- `leave`: an existing object's old value fulfills the query but its new value does not fulfill the query.
- `delete`: an existing object which fulfills the query is deleted.
- `login`: a `_User` is logged in.

The type of data changes need to be identified when a LiveQuery event is received by a client.

#### `create` Events

Assume that there already exist some completed Todos in the app. Now a new uncompleted Todo is added from another client:

```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo"];
todo[@"state"] = @"doing";
[todo saveInBackgroundWithBlock:^(BOOL succeeded, NSError * _Nullable error) {
  /* Saved. */
}];
```
```swift
let todo = AVObject(className: "Todo")
todo["state"] = "doing"
todo.save()
```
```java
AVObject todo = new AVObject("Todo");
todo.put("state", "doing");
todo.saveInBackground(new SaveCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Saved
    }
  }
});
```
```js
var testObj = new AV.Object('Todo');
testObj.set('state', 'doing');
testObj.save();
```
```cs
var testObj = new AVObject("Todo");
testObj["state"] = "doing";
await testObj.SaveAsync();
```

The current client will then receive a `create` event:

```objc
#pragma mark - LiveQuery delegate methods
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidCreate:(id)object {
  if (liveQuery == self.doingLiveQuery) {
    /* A new doing task did create. */
  }
}
```
```swift
#pragma mark - LiveQuery delegate methods

func liveQuery(_ liveQuery: AVLiveQuery, objectDidCreate object: Any) {
  /* A new doing task did create. */
}
```
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectCreated(AVObject avObject) {
    // `avObject` is the AVObject being created
  }
});
```
```js
doingQuery.subscribe().then(function (liveQuery) {
  liveQuery.on('create', function (newDoingItem) {
    // Add `newDoingItem` into `doingList`
  });
});
```
```cs
livequery.OnLiveQueryReceived += (sender, e) => 
{
  if(e.Scope == "create")
  {
    doingList.Add(e.Payload);
  }
};
```

#### `update` Events

The title of an uncompleted Todo is updated from another client (the Todo still remains uncompleted since `state` is not updated):

```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"5915bb92a22b9d005804a4ee"];
todo[@"title"] = @"New Title";
[todo saveInBackgroundWithBlock:^(BOOL succeeded, NSError * _Nullable error) {
  /* Saved. */
}];
```
```swift
let todo = AVObject(className: "Todo", objectId: "5915bb92a22b9d005804a4ee")
todo["title"] = "New Title"
todo.save()
```
```java
AVObject todo = AVObject.createWithoutData("Todo", "5915bb92a22b9d005804a4ee");
todo.put("title", "New Title");
todo.saveInBackground(new SaveCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Saved
    }
  }
});
```
```js
var oneDoing = AV.Object.createWithoutData('Todo', '5915bb92a22b9d005804a4ee');
oneDoing.set('title', 'New Title');
oneDoing.save();
```
```cs
// Assume there is an uncompleted Todo with objectId 5915bb92a22b9d005804a4ee
var oneDoing = AVObject.CreateWithoutData("Todo", "5915bb92a22b9d005804a4ee");
oneDoing["title"] = "New Title";
await oneDoing.SaveAsync();
```

The current client will then receive an `update` event:

```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidUpdate:(id)object updatedKeys:(NSArray<NSString *> *)updatedKeys {
  for (NSString *key in updatedKeys) {
    NSLog(@"%@: %@", key, object[key]);
  }
}
```
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidUpdate object: Any, updatedKeys: [String]) {
  /* A doing task did update. */
}
```
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectUpdated(AVObject avObject, List<String> updateKeyList) {
    // `avObject` is the AVObject being updated; updateKeyList contains the keys being updated
  }
});
```
```js
liveQuery.on('update', function (updatedDoingItem, updatedKeys) {
  // Replace `doingItem` in `doingList` with `updatedDoingItem`
});
```
```cs
livequery.OnLiveQueryReceived += (sender, e) => 
{
  if(e.Scope == "update")
  {
    foreach(var key in e.Keys)
    {
      // The field being updated
      if(key == "title")
      {
        // Retrieve the updated title
        var title = e.Payload.Get<string>(key);
      }
    }
  }
};
```

#### `enter` Events

A **completed** Todo is changed to be **uncompleted** from another client:

```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"591672df2f301e006b9b2829"];
todo[@"state"] = @"doing";
[todo saveInBackgroundWithBlock:^(BOOL succeeded, NSError * _Nullable error) {
  /* Saved. */
}];
```
```swift
let todo = AVObject(className: "Todo", objectId: "591672df2f301e006b9b2829")
todo["state"] = "doing"
todo.save()
```
```java
AVObject todo = AVObject.createWithoutData("Todo", "591672df2f301e006b9b2829");
todo.put("state", "doing");
todo.saveInBackground(new SaveCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Saved
    }
  }
});
```
```js
var todo = new AV.Object.createWithoutData('Todo', '591672df2f301e006b9b2829');
todo.set('state', 'doing');
todo.save();
```
```cs
// Assume there is a completed Todo with objectId 591672df2f301e006b9b2829 
var anotherDone = AVObject.CreateWithoutData("Todo", "591672df2f301e006b9b2829");
anotherDone["state"] = "doing";
await anotherDone.SaveAsync();
```

The current client will then receive an `enter` event:

```objc
#pragma mark - LiveQuery delegate methods
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidEnter:(id)object updatedKeys:(nonnull NSArray<NSString *> *)updatedKeys {
  if (liveQuery == self.doingLiveQuery) {
    /* A todo did change to doing from other state. */
  }
}
```
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidEnter object: Any, updatedKeys: [String]) {
  /* A todo did change to doing from other state. */
}
```
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectEnter(AVObject avObject, List<String> updateKeyList) {
    // `avObject` is the AVObject being updated; updateKeyList contains the keys being updated
  }
});
```
```js
liveQuery.on('enter', function (updatedDoingItem, updatedKeys) {
  // Replace `doingItem` in `doingList` with `updatedDoingItem`
});
```
```cs
livequery.OnLiveQueryReceived += (sender, e) => 
{
  if (e.Scope == "enter")
  {
    doingList.Add(e.Payload);
  }
};
```

The difference between `create` and `enter` is:

- `create`: a new object is created and it fulfills the query.
- `enter`: an existing object's old value does not fulfill the query but its new value fulfills the query.

#### `leave` Events

A **uncompleted** Todo is changed to be **completed** from another client:

```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"591672df2f301e006b9b2829"];
todo[@"state"] = @"done";
[todo saveInBackgroundWithBlock:^(BOOL succeeded, NSError * _Nullable error) {
  /* Saved. */
}];
```
```swift
let todo = AVObject(className: "Todo", objectId: "591672df2f301e006b9b2829")
todo["state"] = "done"
todo.save()
```
```java
AVObject todo = AVObject.createWithoutData("Todo", "591672df2f301e006b9b2829");
todo.put("state", "done");
todo.saveInBackground(new SaveCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Saved
    }
  }
});
```
```js
var todo = new AV.Object.createWithoutData('Todo', '591672df2f301e006b9b2829');
todo.set('state', 'done');
todo.save();
```
```cs
var willDone = AVObject.CreateWithoutData("Todo", "591672df2f301e006b9b2829");
willDone["state"] = "done";
await willDone.SaveAsync();
```

The current client will then receive a `leave` event:

```objc
#pragma mark - LiveQuery delegate methods
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidLeave:(id)object updatedKeys:(nonnull NSArray<NSString *> *)updatedKeys {
  if (liveQuery == self.doingLiveQuery) {
    /* A todo did change to other state from doing. */
  }
}
```
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidLeave object: Any, updatedKeys: [String]) {
  /* A todo did change to other state from doing. */
}
```
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectLeave(AVObject avObject, List<String> updateKeyList) {
    // `avObject` is the AVObject being updated; updateKeyList contains the keys being updated
  }
});
```
```js
liveQuery.on('leave', function (leftDoingItem, updatedKeys) {
  // Remove `leftDoingItem` from `doingList`
});
```
```cs
livequery.OnLiveQueryReceived += (sender, e) => 
{
  if(e.Scope == "leave")
  {
    var done = doingList.First(todo => todo.ObjectId == e.Payload.ObjectId);
    if(done != null)
    {
      doingList.Remove(done);
    }
  }
}
```

#### `delete` Events

An **uncompleted** Todo is deleted from another client:

```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"591d9b302f301e006be22c83"];
[todo deleteInBackgroundWithBlock:^(BOOL succeeded, NSError * _Nullable error) {
  /* Deleted. */
}];
```
```swift
let todo = AVObject(className: "Todo", objectId: "591d9b302f301e006be22c83")
todo.delete()
```
```java
AVObject todo = AVObject.createWithoutData("Todo", "591672df2f301e006b9b2829");
todo.deleteInBackground(new DeleteCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Saved
    }
  }
});
```
```js
var todo = new AV.Object.createWithoutData('Todo', '591d9b302f301e006be22c83');
todo.destroy();
```
```cs
var willDelete = AVObject.CreateWithoutData("Todo", "591d9b302f301e006be22c83");
await willDelete.DeleteAsync();
```

The current client will then receive a `delete` event:

```objc
#pragma mark - LiveQuery delegate methods
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidDelete:(id)object {
  /* A todo has been deleted. */
}
```
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidDelete object: Any) {
  /* A todo has been deleted. */
}
```
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectDeleted(String objectId) {
    // `objectId` is the ID of the AVObject being deleted
  }
});
```
```js
liveQuery.on('delete', function (deletedDoingItem, updatedKeys) {
  // Remove `deletedDoingItem` from `doingList`
});
```
```cs
livequery.OnLiveQueryReceived += (sender, e) => 
{
  if(e.Scope == "delete")
  {
    var done = doingList.First(todo => todo.ObjectId == e.Payload.ObjectId);
    if(done != null)
    {
      doingList.Remove(done);
    }
  }
}
```

### Unsubscribing

Different than [Losing Connections](#losing-connections), unsubscribing means to permanently stop receiving updates with LiveQuery.

If [the connection to the server is lost](#losing-connections) before a subscription is unsubscribed, the subscription will resume automatically after the connection is built.

The code below shows how you can fully unsubscribe a subscription:

```objc
[liveQuery unsubscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
  if (succeeded) {
    // Unsubscribed
  } else {
    // Error happened
  }
}];
```
```swift
liveQuery.unsubscribe { (succeeded, error) in
  if succeeded {
    // Unsubscribed
  } else {
    // Error happened
  }
}
```
```java
liveQuery.unsubscribeInBackground(new AVLiveQuerySubscribeCallback() {
  @Override
  public void done(AVException ex) {
    if (null != ex) {
      // Error happened
    } else {
     // Unsubscribed
    }
  }
});
```
```js
liveQuery.unsubscribe().then(function () {
  // Unsubscribed
}).catch(function (error) {
  // Error happened
});
```
```cs
await liveQuery.UnsubscribeAsync();
```

### Losing Connections

A client's connection to the server can be lost due to the following reasons:

1. Errors happen to the network, or the user switches the network.
2. The user leaves the app, turns off the device, or switches to flight mode.

For the situations mentioned above, there's no need for you to handle them by yourself. The SDK will automatically resume the subscription once the connection is built.

However, **if the user fully kills the client of the app or closes the webpage running it**, the SDK will not be able to resume the subscription by itself. You can always create a new subscription if you need to.

### FAQ

- What is a bad practice of using LiveQuery?

  Since LiveQuery delivers messages in real time, some developers may try to implement a real-time messaging function with it, which we do not recommend because additional storage will be used by doing so and additional cost may occur. It's also hard to maintain the code written for such function with LiveQuery. LeanCloud offers a fully functional RTM service which you can use to build such feature.

{% block text_js_promise %}{% endblock %}

## Users

Almost all the apps require their users to create accounts before they could access certain features. Some mobile apps may also allow their users to log in with phone numbers. {{productName}} offers a total solution for you to quickly implement such features.

Here we use `{{userObjectName}}` as a special object to represent each user. All the instances of it will be stored in `_User` table.

### User Properties

#### Default User Properties

Each user has three default properties: username, password, and email. The following code shows how these properties can be retrieved:

{% block code_get_user_properties %}{% endblock %}

Keep in mind that password can only be set when a user creates an account (see [Signing up with Usernames and Passwords](#signing-up-with-usernames-and-passwords)) and will not be stored locally afterwards. The password field of a logged in user is **empty**.

#### Custom User Properties

Custom properties can be assigned to a user just like how they can be assigned to a basic object. The following code adds `age` as a custom property of the current user:

{% block code_set_user_custom_properties %}{% endblock %}

#### Updating User Properties

"Why can't I update other users' properties?"

> The users of your app may store a lot of sensitive information in their accounts, including phone numbers, social media accounts, etc. Sometimes even developers of the app themselves are not encouraged to manipulate users' properties on their own. To protect the privacy of users, all the requests regarding `{{userObjectName}}` objects will be authenticated by the cloud before they take effect.

The following code updates the `age` of the current user:

{% block code_update_user_custom_properties %}{% endblock %}

Custom properties of `{{userObjectName}}` can be used in the same way as those of `{{baseObjectName}}`.

### Signing up

#### Signing up with Phone Numbers and Passwords

Sometimes an app would allow a user to access some contents without signing up until certain functions are triggered. When the user needs to sign up, they can simply complete the process by providing a phone number and receiving a verification code.

The following code sends a verification code to a number:

{% block code_send_sms_code_for_loginOrSignup %}{% endblock %}

The following code logs the user in with the code collected from their input:

{% block code_verify_sms_code_for_loginOrSignup %}{% endblock %}

#### Signing up with Usernames and Passwords

When creating a user with username and password, the SDK sends the password to the cloud in plaintext through HTTPS and the password will be hashed once it arrives to the cloud. The hashing algorithm used in the cloud ensures that the original password cannot be retrieved by rainbow table attack and even app developers themselves will not be able to see the password. Keep in mind that <u>the password should not be encrypted by the client, or the password reset function will not work</u>.

The following code creates a user with `Tom` as username and `cat!@#123` as password:

{% block code_user_signUp_with_username_and_password %}{% endblock %}

If the code returns the error 202, it means that a user with the same `username` already exists in `_User` table and the client should prompt the user to try a different username. It is also required that each `email` or `mobilePhoneNumber` appears only once in the corresponding column, otherwise error 203 or 214 will occur.

You may also ask a user to sign up with their email address without an additional username so that the user can directly [reset their password with email](#resetting-passwords).

#### Setting Phone Numbers

Many apps require their users to link their accounts with phone numbers for account verification and password reset. If you need the same functionality in your app, see {{ sms_guide_url }} for more details.

#### Verifying Email Addresses

You can request that your users have their email addresses verified before they can access certain functions in your app. By doing so it gets harder for spam users to abuse your app. If you check on **Send verification emails to users after signing up** in {{app_permission_link}}, an email containing verification link will be sent to each `AVUser` created with an email address. The user is considered to be verified if the link is clicked on.

If a user forgets to click on the link and needs to have their account verified later, the following code can be used to send a new email to them:

{% block code_send_verify_email %}{% endblock %}

Keep in mind that a verification email will be sent out automatically if the email of `AVUser` is updated with `setEmail()`. `requestEmailVerify` **does not** need to be called in this scenario.

### Logging in

Below are the ways you can use to log a user in.

#### Logging in with Usernames and Passwords

{% block code_user_logIn_with_username_and_password %}{% endblock %}

#### Logging in with Phone Numbers and Passwords

More information can be found at {{ sms_guide_url }}.

{% block code_user_logIn_with_mobilephonenumber_and_password %}{% endblock %}

Keep in mind that users with unverified numbers are able to log in with the method above. If you need to prevent them from logging in, check on **Prevent users with unverified numbers from logging in** in {{app_permission_link}}.

#### Logging in with Phone Numbers and Verification Codes

The code below sends a verification code to a number:

{% block code_user_logIn_requestLoginSmsCode %}{% endblock %}

The following code logs the user in with the code collected from their input:

{% block code_user_logIn_with_smsCode %}{% endblock %}

{{ sms.fixedVerificationCode("####") }}

#### Single Device Sign-on

By following the steps below, a user will get all the other sessions expired once they log in on a device:

1. Create a table in the cloud that keeps track of each user's credentials and their device information.
2. Once a user logs in on a device, update the device information of this user to be the current device.
3. When the app running on another device is opened, check if the device matches the one stored in the cloud. If it does not, call `logout` on AVUser to log out.

#### Current User

After a user is logged in, LeanCloud SDK automatically stores the session information of this user in the client so that the user does not need to log in each time they open the client. The following code checks if there is a user logged in:

{% block code_current_user %}{% endblock %}

The session information of a user will remain in the client until the user is [logged out](#logging-out).

#### Session Tokens

A SessionToken will be returned to the client after a user is logged in, which will be used for authenticating requests made by the same `{{userObjectName}}` in the future and will be included in the Header of each HTTP request made from the client with {{sdk_name}}.

If **Require users to re-log in after changing password** is checked on in {{app_permission_link}}, the SessionToken of a user will be reset in the cloud after this user changes the password and the client needs to prompt the user to log in again, otherwise [403 (Forbidden)](error_code.html#_403) will be returned as an error.

##### Validating `SessionToken`

{% block code_user_isAuthenticated %}{% endblock %}

##### Logging in with `SessionToken`

Below are the situations when you may need to log a user in with SessionToken:

- A SessionToken is already available in a previous cache.
- A WebView within the app needs to know the current user.
- The user is logged in on the server side and the server provides the SessionToken to the client.

{% block code_authenticate_via_sessiontoken %}{% endblock %}

{{ docs.alert("For security reasons, please avoid passing SessionToken as a part of URL to a third-party browser.") }}

#### Account Lockout

If the wrong password or verification code is entered for an account for more than 6 times within 15 minutes, the account will be disabled temporarily and the error code 1 will be returned.

The account will be automatically recovered 15 minutes after the last attempt and the process cannot be expedited through SDK or REST API. While the account is disabled, the user cannot be logged in even though the correct credentials are provided. The restriction applies to both SDK and LeanEngine.

### Resetting Passwords

#### Resetting Passwords with Emails

The following code sends a password reset email to the user:

{% block code_reset_password_by_email %}{% endblock %}

Here is the process of resetting password:

1. The user enters the email address used for the account.
2. {{productName}} sends an email to the address including a link for resetting password.
3. After the user clicks on the link, a new page will pop up, asking for a new password.
4. The password will be reset after the user enters a new password.

#### Resetting Passwords with Phone Numbers

The code below sends a verification code to the phone number provided:

{% block code_reset_password_by_mobilephoneNumber %}{% endblock %}

The code below resets the password for the user:

{% block code_reset_password_by_mobilephoneNumber_verify %}{% endblock %}

### Logging out

The following code logs the current user out by removing their credentials from the cache:

{% block code_current_user_logout %}{% endblock %}

### Queries on Users

For security reasons, **the `_User` table of each new app has its `find` permission disabled by default**. Each user can only access their own data in `_User` table and cannot access that of others. If you need to allow each user to view other users' data, we recommend that you create a new table to store such data and enable the `find` permission of this table.

You may also encapsulate queries on users within [LeanEngine](leanengine_overview.html) and avoid opening up `find` permissions of `_User` tables.

The following code creates a query on users:

{% block code_query_user %}{% endblock %}

### Anonymous Users

The following code creates a new user without asking for any credentials:

{% block anonymous_user_login %}{% endblock %}

An anonymous user can be converted to a normal user with one of the following operations:

- Set a username and password.
- [Link to a third-party app](#linking-users).

The following code sets a username and password for an anonymous user:

{% block setup_username_and_password_for_anonymous_user %}{% endblock %}

The following code tells if the current user is anonymous:

{% block determine_a_user_is_anonymous %}{% endblock %}

If an anonymous user is not converted to a normal user before they log out, they will not be able to log in to the same account later and the data stored in that account cannot be retrieved anymore.

## Roles

We have a dedicated documentation explaining the relationship between users and roles, including the permission managements with them. See [ACL Guide](acl-guide.html).

## Linking Users

It is a common practice that an app allows their users to log in with their existing third-party accounts (like Facebook or Twitter). This makes it possible to reduce the time needed for a user to create their account.

Here is the basic steps for implementing such function:

1. Set up platform account.
2. Retrieve authData of a user from the platform.
3. Link authData to AVUser on LeanCloud.

### Basic Steps for Linking Users

#### Setting up Platform Accounts

You can put the **App ID** and **App Secret Key** of the platform into [Dashboard > Components > SNS](/dashboard/devcomponent.html?appid={{appid}}#/component/sns). A **callback URL** and **log in URL** will be generated after they are saved.

After completing the configuration above, LeanCloud will automatically validate each authData with the corresponding platform to make sure that each AVUser is linked to a valid user of the platform. If you do not want authData to be validated, **check off** "Validate AccessToken when linking accounts" in [Dashboard > Components > SNS](/dashboard/devcomponent.html?appid={{appid}}#/component/sns).

#### Retrieving authData and Creating AVUser

After retrieving authData, call `loginWithauthData` or `associateWithauthData` to bind it with an AVUser. The data will be stored in the field `authData` of `_User` table.

Each authData needs to contain at least three properties: `openid or uid`, `access_token`, and `expires_in`. `openid` is for WeChat and QQ. `uid` is for all other platforms.

The code below can be used to have a user sign up or log in with authData. If an AVUser with the authData does not exist, a new one will be created.

{% block login_with_authdata %}{% endblock %}

The new AVUser will be created in the _User table with the following data:

{% block login_with_authdata_result %}{% endblock %}

If an AVUser with the authData already exists, the AVUser will be returned and can be used to log in.

If an existing AVUser is linking a new third-party account, the authData from the platform will be added to the AVUser:

{% block associate_with_authdata %}{% endblock %}

A new field `qq` will be added to the authData of the AVUser:

{% block associate_with_authdata_result %}{% endblock %}

### Advanced Features

#### Collecting Additional Information from New Users

If you need your users to provide additional information (username, phone number, password, etc.) when logging in with third-party accounts, you can set `failOnNotExist` of `loginWithauthData` to be `true` so that the cloud would check if there is already a user with the authData and return error 211 (`Could not find user`) if there is not. With this error code, you can take your user to another page to fill out the additional information. Once they are done, save these information into a new AVUser object and call `loginWithauthData` again **without `failOnNotExist`** for logging in:

{% block login_with_authdata_without_fail %}{% endblock %}

{% block module_in_app_search %}
## In-App Searching

In-app searching is built with search engine that gives your app the ability to search data among an entire dataset. For more details, see {{inapp_search_guide_url}}.
{% endblock %}

{% block module_in_app_social %}
## In-App Socializing

In-app socializing offers features like following, timeline, status update, interaction, messaging, etc. For more details, see {{status_system_guide_url}}.
{% endblock %}

{% block js_push_guide %}{% endblock %}

{% block use_js_in_webview %}{% endblock %}

{% block faq %}{% endblock %}
