{% import "views/_helper.njk" as docs %}
{% import "views/_data.njk" as data %}

# LeanStorage {{platform_name}} Guide

The LeanStorage {{platform_name}} SDK can be used to persist and query data in LeanCloud. The code below shows how you can create an object and store it into the cloud:

{% if platform_name === "JavaScript" %}
```js
// Declare Class
var Todo = AV.Object.extend('Todo');

// Create an object
var todo = new Todo();

// Set values of fields
todo.set('title',   'R&D Weekly Meeting');
todo.set('content', 'All team members, Tue 2pm');

// Save data to the cloud
todo.save().then(function (todo) {
  // Execute any logic that should take place after the object is saved
  console.log('New object created with objectId: ' + todo.id);
}, function (error) {
  // Execute any logic that should take place if the save fails
  console.error('Failed to create new object, with error message: ' + error.message);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Create an object
let todo = LCObject(className: "Todo")

// Set values of fields
todo.set("title",   value: "R&D Weekly Meeting")
todo.set("content", value: "All team members, Tue 2pm")

// Save data to the cloud
todo.save { result in
    switch result {
    case .success:
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Create an object
AVObject todo = new AVObject("Todo");

// Set values of fields
todo.put("title",   "R&D Weekly Meeting");
todo.put("content", "All team members, Tue 2pm");

// Save data to the cloud
todo.saveInBackground(new SaveCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // Execute any logic that should take place after the object is saved
        } else {
            // Execute any logic that should take place if the save fails
        }
    }
});
```
{% endif %}

{% call docs.noteWrap() %}
The SDK designed for each language interacts with the same [REST API](rest-api.html) via HTTPS, offering fully functional interfaces for you to manipulate the data in the cloud.
{% endcall %}

## Getting Started

{% if platform_name === "JavaScript" %}
The JavaScript SDK supports Chrome 45+, recent versions of Firefox, IE 10+, Edge, iOS 9.3+, Android 4.4+, WeApp DevTools, Node.js 4.0+, React Native 0.26+, and Electron.
{% endif %}
{% if platform_name === "Swift" %}
{# TODO #}
{% endif %}
{% if platform_name === "Android" %}
{# TODO #}
{% endif %}

{# 2018-12-30 上述对浏览器、操作系统、开发平台版本的描述要不要分离？ #}

### Installing SDK

{% if platform_name === "JavaScript" %}
The easiest way to integrate our JavaScript SDK in your project is to use npm:

```bash
$ npm install leancloud-storage --save
```

To use npm for a browser based application or in a Node.js environment, include it as you normally would:

```js
var AV = require('leancloud-storage');

// Create references to the global AV
var { Query, User } = AV;

// Initialize SDK
AV.init('APP_ID', 'APP_KEY');
```

You may also use a pre-compiled SDK file in your webpage with the following `<script>` tag:

```html
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@{{jssdkversion}}/dist/av-min.js"></script>
```

And then create references to the SDK:

```js
// Create references to the global AV
var { Query, User } = AV;

// Initialize SDK
AV.init('APP_ID', 'APP_KEY');
```

Check out our Github repo https://github.com/leancloud/javascript-sdk/releases for more releases and file formats.

If you plan to use our JavaScript SDK inside Android WebView, please check out [WebView](#webview) section of this guide.

If you plan to use [LiveQuery](#live-queries), include the following npm module instead:

```js
// No need to require 'leancloud-storage' if the following line is present
var AV = require('leancloud-storage/live-query');
```

Or load it with the following `<script>` tag: 

```html
<!-- No need to load av-min.js if the following script is present -->
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@{{jssdkversion}}/dist/av-live-query-min.js"></script>
```

You also need to go to your app's [Dashboard > Storage > Settings](/dashboard/storage.html?appid={{appid}}#/storage/conf) and check the **Enable LiveQuery** option under the **Misc** section before you can expect it to work.
{% endif %}
{% if platform_name === "Swift" %}
{# TODO #}
{% endif %}
{% if platform_name === "Android" %}
{# TODO #}
{% endif %}

### Initializing Your Application

First, go to your app's [Dashboard > Settings](/dashboard/app.html?appid={{appid}}#/key) and look for your App ID and App Key.

{% if platform_name === "JavaScript" %}
Next, copy and paste them into your initialization code:

```js
var APP_ID  = '{{appId}}';
var APP_KEY = '{{appKey}}';

// Same as using AV.init('APP_ID', 'APP_KEY')
AV.init({
  appId:  APP_ID,
  appKey: APP_KEY,
  region: 'us' // Defaults to China if not specified
});
```
{% endif %}
{% if platform_name === "Swift" %}
Next, add the following line to the top of `AppDelegate.swift`:

```swift
import LeanCloud
```

Then add the code below into the function `application:didFinishLaunchingWithOptions`:

```swift
LCApplication.default.set(
    id:  "{{appId}}",
    key: "{{appKey}}"
)
```
{% endif %}
{% if platform_name === "Android" %}
Next, create a Java Class named `MyLeanCloudApp` inheriting `Application`:

```java
public class MyLeanCloudApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        AVOSCloud.initialize(this, "{{appId}}", "{{appKey}}");
    }
}
```

Then specify the permissions needed by the SDK and declare the `MyLeanCloudApp` class in `AndroidManifest.xml`:

```xml
<!-- Basic modules (required) START -->
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
<!-- Basic modules END -->

<application
  ...
  android:name=".MyLeanCloudApp" >

  <!-- RTM modules and push notifications START -->
  <!-- Both RTM modules and push notifications need PushService -->
  <service android:name="com.avos.avoscloud.PushService"/>
  <receiver android:name="com.avos.avoscloud.AVBroadcastReceiver">
    <intent-filter>
      <action android:name="android.intent.action.BOOT_COMPLETED"/>
      <action android:name="android.intent.action.USER_PRESENT"/>
      <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
    </intent-filter>
  </receiver>
  <!-- RTM modules and push notifications END -->

  <!-- Feedback START -->
  <activity
     android:name="com.avos.avoscloud.feedback.ThreadActivity" >
  </activity>
  <!-- Feedback END -->
</application>
```
{% endif %}

Apps running on LeanCloud are region-specific, which means that no data will be communicated across regions. Therefore, incorrect region settings will cause the initialization to fail.

Each region has its own REST APIs. Please refer to the following documentations for the correct URL schemes of APIs to be used:

- Docs for US: https://us.leancloud.cn/docs/rest_api.html.
- Docs for China: https://leancloud.cn/docs/rest_api.html.

### Debugging

You can easily trace the problems in your application by turning debug logs on during the development phase. Once enabled, details of every request made by the SDK along with errors will be output to IDE, browser console, or [Dashboard > LeanEngine > Logs](/dashboard/cloud.html?appid={{appid}}#/log).

{% if platform_name === "JavaScript" %}
```js
// In Node.js, set environment variable DEBUG=leancloud*
// Debug logs will be enabled when running app with npm
DEBUG=leancloud* npm start

// If using Node.js with LeanEngine, go to Dashboard > LeanEngine > Settings > Custom Environment Variables
// Put DEBUG in the first field and leancloud:* in the second field (make sure to include the colon between leancloud and *)
DEBUG=leancloud:* lean up

// Set localStorage in browser console
localStorage.setItem('debug', 'leancloud*');

// Enable debug logs for LiveQuery
localStorage.setItem('debug', 'LC*');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Place the line after AVOSCloud.initialize()
AVOSCloud.setDebugLogEnabled(true);
```
{% endif %}

{% call docs.alertWrap() %}
Make sure debug logs are turned off before your app is published. Failure to do so may lead to the exposure of sensitive data.
{% endcall %}

{% if platform_name === "JavaScript" %}
### Web Security

If you are using our JavaScript SDK in your browser based application, you must configure **whitelist domains** in your app's [Dashboard > Settings](/dashboard/app.html?appid={{appid}}#/security) before you deploy it to a production environment. Once set up, our backend will only accept requests sent from domains in the whitelist, which prevents unauthorized usage or access to your cloud data on a certain level.

However, since your app is exposed to the internet, simply setting up whitelist domains can't totally guarantee the security of your app. LeanCloud offers a variety of ways to help you secure your apps as well as the data stored within them. The following articles give you the necessary information you need to know regarding app security.

- [Data and Security](data-security.html)
- [ACL Guide](acl-guide.html)
{% endif %}

## Objects

### `{{ baseObjectName }}`

Storing data on LeanCloud is built around `{{ baseObjectName }}`. Each `{{ baseObjectName }}` contains key-value pairs of JSON-compatible data. This data is schemaless, which means that you don't need to specify ahead of time what keys exist on each `{{ baseObjectName }}`. Simply set whatever key-value pairs you want, and our backend will store it.

For example, the `{{ baseObjectName }}` storing a simple todo item may contain the following data:

```json
title:       "Email Linda to confirm appointment"
isComplete:  false,
priority:    2,
tags:        ["work", "sales"]
```

{# Keys must be alphanumeric strings. Values can be strings, numbers, booleans, or even arrays, objects, and anything that can be JSON-encoded. #}

### Data Types

`{{ baseObjectName }}` supports a wide range of data types to be used for each field, including common ones like String, Number, Boolean, Object, Array, Date, JSON, and null. You can nest JSON Objects and JSON Arrays to store more structured data within a single object.

Special data types supported by `{{ baseObjectName }}` include Pointer and File, which are used to store a reference to another `{{ baseObjectName }}` and binary data respectively.

`{{ baseObjectName }}` also supports GeoPoint, a special data type you can use to store location-based data. See [GeoPoints](#geopoints) for more details.

Some examples:

{% if platform_name === "JavaScript" %}
```js
// Declare Class
var TestObject = AV.Object.extend('DataTypeTest');

// Basic objects
var number = 2018;
var string = 'famous film name is ' + number;
var date   = new Date();
var array  = [string, number];
var object = {
  number: number,
  string: string
};

// An AV.Object with another Class
var pointer = AV.Object.createWithoutData('Todo', '5745557f71cfe40068c6abe0');

// Create an object
var testObject = new TestObject();
testObject.set('testNumber', number);
testObject.set('testString', string);
testObject.set('testDate', date);
testObject.set('testArray', array);
testObject.set('testObject', object);
testObject.set('testNull', null);
testObject.set('testPointer', pointer);
testObject.save().then(function (testObject) {
  // Success
}, function (error) {
  // Failure
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let number     : LCNumber     = 42
let bool       : LCBool       = true
let string     : LCString     = "foo"
let object     : LCObject     = LCObject()
let dictionary : LCDictionary = LCDictionary(["name": string, "count": number])
let array      : LCArray      = LCArray([number, bool, string])
let relation   : LCRelation   = object.relationForKey("elements")
let acl        : LCACL        = LCACL()
let point      : LCGeoPoint   = LCGeoPoint(latitude: 45, longitude: -45)
let date       : LCDate       = LCDate()
let data       : LCData       = LCData()
let null       : LCNull       = LCNull()
```
{% endif %}
{% if platform_name === "Android" %}
```java
boolean bool = true;
int number = 2018;
String string = number + " Top Hit Songs";
Date date = new Date();

byte[] data = "Hello World".getBytes();
ArrayList<Object> arrayList = new ArrayList<>();
arrayList.add(number);
arrayList.add(string);
HashMap<Object, Object> hashMap = new HashMap<>();
hashMap.put("myNumber", number);
hashMap.put("myString", string);

AVObject object = new AVObject("DataTypes");
object.put("testBoolean", bool);
object.put("testInteger", number);
object.put("testDate", date);
object.put("testData", data);
object.put("testArrayList", arrayList);
object.put("testHashMap", hashMap);
object.saveInBackground();
```
{% endif %}

We do not recommend storing large pieces of binary data like images or documents with `{{ baseObjectName }}`{% if platform_name === "Android" %} using `byte[]`{% endif %}. The size of each `{{ baseObjectName }}` should not exceed **128 kilobytes**. We recommend using `{{ fileObjectName }}` for storing images, documents, and other types of files. To do so, create `{{ fileObjectName }}` objects and assign them to fields of `{{ baseObjectName }}`. See [Files](#files) for details.

{% call docs.noteWrap() %}
Keep in mind that our backend stores dates in UTC format and the SDK will convert them to local times upon retrieval.

The date values displayed in the Data Browser in [Dashboard > Data](/dashboard/data.html?appid={{appid}}#/) are also converted to match your operating system's timezone. The only exception is that when you retrieve these date values through our [REST API](rest-api.html), they will remain in UTC format. You can manually convert them using appropriate timezones when necessary.
{% endcall %}

{# For more information about how LeanCloud handles data and security, check out our documentation on [Data and Security](data-security.html). #}

### Creating Objects

The code below creates a new instance of `{{ baseObjectName }}`:

{% if platform_name === "JavaScript" %}
```js
// Create a new subclass of AV.Object
var Todo = AV.Object.extend('Todo');

// Create a new instance of that Class
var todo = new Todo();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVObject todo = new AVObject("Todo");
```
{% endif %}

`{{ baseObjectName }}{% if platform_name === "JavaScript" %}.extend(){% endif %}` takes ClassName as a parameter so that the cloud knows the Class you are using to create the object. A Class in LeanCloud is comparable to a table in a relational database.

A ClassName starts with a letter and can only contain numbers, letters, and underscores.

{% if platform_name === "JavaScript" %}
{% call docs.noteWrap() %}
If you keep seeing "**Maximum call stack size exceeded**" exception in your log, chances are `AV.Object.extend()` had been called using the same ClassName more than once within a loop or a callback. To resolve such issue, either move it out of the loop or the callback to make sure it won't be over-instantiated, or switch to JavaScript SDK 1.4 or higher which handles the problem automatically.
{% endcall %}

From version 1.4.0 onwards, the JavaScript SDK is compatible with ES6 classes. If you're using ES6 in your codebase, you can subclass `AV.Object` with the **extends** keyword. However, when using extends, the SDK is not automatically aware of your subclasses. You will need to register the subclasses with the SDK:

```js
class Todo extends `AV.Object` {
  // More properties and methods
}

// Register the subclass
AV.Object.register(Todo);
```

After doing this, you will be able to add additional methods and properties to your subclasses of `AV.Object`.
{% endif %}

{# You can also use the `AV.Object` constructor directly. `new AV.Object(ClassName)` will create a single LeanCloud Object with that Class name. #}

### Saving Objects

The following code saves a new Class named "**Todo**" to the cloud:

{% if platform_name === "JavaScript" %}
```js
var Todo = AV.Object.extend('Todo');
var todo = new Todo();

// Set values of fields
todo.set('title', 'Sign up for Marathon');
todo.set('priority', 2);

// Save data to the cloud
todo.save().then(function (todo) {
  // Execute any logic that should take place after the object is saved
  console.log('New object created with objectId: ' + todo.id);
}, function (error) {
  // Execute any logic that should take place if the save fails
  console.error('Failed to create new object, with error message: ' + error.message);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")

// Set values of fields
todo.set("name", value: "Sign up for Marathon")
todo.set("priority", value: 2)

// Save data to the cloud
todo.save { result in
    switch result {
    case .success:
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVObject todo = new AVObject("Todo");

// Set values of fields
todo.put("name", "Sign up for Marathon");
todo.put("priority", 2);

// Save data to the cloud
todo.saveInBackground();
```
{% endif %}

To make sure the data is successfully saved, take a look at [Dashboard > Data > Todo](/data.html?appid={{appid}}#/) in your app. You should see something like this when you click on the objectId of the object:

```json
{
  "title":      "Sign up for Marathon", 
  "priority":   2, 
  "ACL": {
    "*": {
      "read":   true,
      "write":  true
    }
  },
  "objectId":   "582570f38ac247004f39c24b", 
  "createdAt":  "2017-11-11T07:19:15.549Z",
  "updatedAt":  "2017-11-11T07:19:15.549Z"
}
```

{% call docs.noteWrap() %}
You don't have to create or set up a new Class called "Todo" before running the code above. The Class will be automatically created in your app when it is first encountered.
{% endcall %}

There are several built-in fields that are provided by default which you don't need to specify in your code:

Built-in Field | Type | Description
--- | --- | ---
`objectId` | {{ "str" if platform_name === "Python" else "String" }} | A unique identifier for each saved object.
`ACL` | {{ "leancloud.ACL" if platform_name === "Python" else "ACL" }} | Access Control List, a JSON-compatible data defining the read and write permissions of other people.
`createdAt` | {% if platform_name === "JavaScript" %}Date{% endif %}{% if platform_name === "Swift" %}NSDate{% endif %}{% if platform_name === "Android" %}Date{% endif %} | The time the object was created.
`updatedAt` | {% if platform_name === "JavaScript" %}Date{% endif %}{% if platform_name === "Swift" %}NSDate{% endif %}{% if platform_name === "Android" %}Date{% endif %} | The time the object was last modified.

Each of these fields is filled in by the cloud automatically and doesn't exist on the local `{{ baseObjectName }}` until a save operation has been completed.

Field names, or **keys**, must be alphanumeric strings. A custom key can neither start with double underscores `__`, nor be identical to any system reserved words or built-in field names regardless of letter cases.

Here are the words you should avoid using as names of your keys: **{{ data.preservedWords(", ") }}**.

**Values** can be strings, numbers, booleans, or even arrays and dictionaries — anything that can be JSON-encoded. See [Data Types](#data-types) for more information.

We recommend that you adopt CamelCase naming convention to `NameYourClassesLikeThis` and `nameYourKeysLikeThis`, which keeps your code more readable.

### Retrieving Objects

If `{{ baseObjectName }}` is already in the cloud, you can retrieve it using its `objectId` with the following code:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.get('57328ca079bc44005c2472d0').then(function (todo) {
  // todo is successfully retrieved
  var priority  = todo.get('priority');
  var location  = todo.get('location');
  var title     = todo.get('title');
  var content   = todo.get('content');

  // Acquire special properties
  var objectId  = todo.id;
  var updatedAt = todo.updatedAt;
  var createdAt = todo.createdAt;
}, function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.get("558e20cbe4b060308e3eb36c") { result in
    switch result {
    case .success(let todo):
        // todo is successfully retrieved
        let priority = todo.get("location") as! LCNumber
        let location = todo.get("location") as! LCString
        let title    = todo.get("title") as! LCString
        let content  = todo.get("content") as! LCString

        // Acquire special properties
        let objectId  = todo.objectId
        let updatedAt = todo.updatedAt
        let createdAt = todo.createdAt
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> avQuery = new AVQuery<>("Todo");
avQuery.getInBackground("57328ca079bc44005c2472d0", new GetCallback<AVObject>() {
    @Override
    public void done(AVObject avObject, AVException e) {
        if (e == null) {
            // todo is successfully retrieved
            int priority     = avObject.getInt("priority");
            String location  = avObject.getString("location");
            String title     = avObject.getString("title");
            String content   = avObject.getString("content");

            // Acquire special properties
            String objectId  = avObject.getObjectId();
            Date updatedAt   = avObject.getUpdatedAt();
            Date createdAt   = avObject.getCreatedAt();
        } else {
            // Error handling
        }
    }
});
```
{% endif %}

After retrieving an object, use the `get` method to acquire the data stored in its fields.

Be aware that **objectId**, **updatedAt**, and **createdAt** are 3 special properties that cannot be retrieved using the `get` method or modified with the `set` method. Each of these fields is filled in by the cloud only, so they don't exist on `{{ baseObjectName }}` until a save operation has been completed.

If you try to access a field or property that doesn't exist, the SDK will return a **null** instead of raising an error.

{% if platform_name === "JavaScript" %}
Sometimes you may want to get all the fields back at one time (which usually happens when performing data binding) without calling `get` on each field of the object. If your SDK version is 3.0.0+, you may call `toJSON` on `AV.Object` to get a plain JSON object containing all the fields of the object.

```js
var query = new AV.Query('Todo');
query.get('558e20cbe4b060308e3eb36c').then(function (todo) {
  console.log(todo.toJSON());
  // ==== Results in console ====

  // title:      "R&D Weekly Meeting"
  // content:    "All team members, Tues 2pm"
  // location:   "Meeting Room B"
  // priority:   2
  // objectId:   "558e20cbe4b060308e3eb36c"
  // createdAt:  "2017-03-08T11:25:07.804Z"
  // updatedAt:  "2017-03-08T11:25:07.804Z"
  // ...

}).catch(function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}

#### Refreshing Objects

If you need to refresh a local object with the latest version of it in the cloud, call the `{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}{% if platform_name === "Android" %}fetchInBackground{% endif %}` method on it:

{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '5745557f71cfe40068c6abe0');
todo.fetch().then(function (todo) {
  // todo is refreshed
}, function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "575cf743a3413100614d7d75")
todo.fetch { result in
    switch result {
    case .success:
        // todo is refreshed
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "5656e37660b2febec4b35ed7");
todo.fetchInBackground(new FetchCallback<AVObject>() { // fetchInBackground is equivalent to refreshInBackground
    @Override
    public void done(AVObject avObject, AVException e) {
        if (e == null) {
            // todo is refreshed
        } else {
            // Error handling
        }
    }
});
```
{% endif %}

Keep in mind that **any unsaved changes made to the object prior to calling `{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}{% if platform_name === "Android" %}fetchInBackground{% endif %}` will be discarded**. To avoid this, you have the option to provide **a list of keys** to the `{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}{% if platform_name === "Android" %}fetchInBackground{% endif %}` method so that only the fields being specified are retrieved and refreshed (including special built-in fields such as objectId, createdAt, and updatedAt). Changes made to other fields will remain intact.

{% if platform_name === "JavaScript" %}
```js
todo.fetch({
  keys: 'priority, location'
}).then(function (todo) {
  // Only priority and location will be retrieved and refreshed
}, function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "564d7031e4b057f4f3006ad1");
String keys = "priority, location";
todo.fetchInBackground(keys, new FetchCallback<AVObject>() {
    @Override
    public void done(AVObject avObject, AVException e) {
        if (e == null) {
            // Only priority and location will be retrieved and refreshed
            String priority = avObject.getString("priority");
            String location = avObject.getString("location");
        } else {
           // Error handling
        }
    }
});
```
{% endif %}

{# After the object is refreshed successfully, its `updatedAt` value will be updated on the client. The cloud won't have this new value until the next save or fetch happens, thus some network bandwidth can be saved out of it. #}

{# With that in mind, let's make it more fun. Let's build a new `AV.Object` locally from scratch with an objectId, and retrieve more field values associated with this object from the cloud without using `AV.Query`. #}

### Updating Objects

To update an existing object, assign the new data to each field and call the `{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Swift" %}save{% endif %}{% if platform_name === "Android" %}saveInBackground{% endif %}` method. For example:

{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '5745557f71cfe40068c6abe0');
todo.set('content', 'Weekly meeting has been rescheduled to Wed 3pm for this week.');
todo.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "575cf743a3413100614d7d75")
todo.set("content", value: "Weekly meeting has been rescheduled to Wed 3pm for this week.")
todo.save()
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "558e20cbe4b060308e3eb36c");
todo.put("content", "Weekly meeting has been rescheduled to Wed 3pm for this week.");
todo.saveInBackground();
```
{% endif %}

LeanCloud automatically figures out which data has changed and only fields with changes will be sent to the cloud. The fields you didn't update will remain intact.

#### Updating Data Conditionally

By passing a `query` option into the `{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Swift" %}save{% endif %}{% if platform_name === "Android" %}saveInBackground{% endif %}` method, you can specify conditions on the save operation so that the object can be updated atomically only when those conditions are met. If no object matches the conditions, the cloud will return error code **305** to indicate that there was no update taking place.

For example, in the Class "Account" there is a field called **balance**, and there are multiple incoming requests that will modify the balance. An account cannot have negative balance, so we can only allow a request to update the balance when the amount requested is lower than or equal to the balance:

{% if platform_name === "JavaScript" %}
```js
var Account = AV.Object.extend('Account');
new AV.Query(Account).first().then(function (account) {
  // Atomically decrease balance by 100
  var amount = -100;
  account.increment('balance', amount);
  return account.save(null, {
    // Add the condition
    query: new AV.Query(Account).greaterThanOrEqualTo('balance', -amount),

    // Return the latest data in the cloud upon completion.
    // All the fields will be returned if the object is new,
    // otherwise only fields with changes will be returned.
    fetchWhenSave: true
  });
}).then(function (account) {
  // Object updated
  console.log('Balance: ', account.get('balance'));
}).catch(function (error) {
  if (error.code === 305) {
    console.log('Insufficient balance. Operation failed!');
  }
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Atomically decrease balance by 100
final int amount = -100;
AVQuery<AVObject> query = new AVQuery<>("Account");
query.getFirstInBackground(new GetCallback<AVObject>() {
    @Override
    public void done(final AVObject account, AVException e) {
        account.increment("balance", amount);
        AVSaveOption option = new AVSaveOption();
        // Add the condition
        option.query(new AVQuery<>("Account").whereGreaterThanOrEqualTo("balance", -amount));

        // Return the latest data in the cloud upon completion.
        // All the fields will be returned if the object is new,
        // otherwise only fields with changes will be returned.
        option.setFetchWhenSave(true);
        account.saveInBackground(option, new SaveCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {
                    System.out.println("Balance: " + account.get("balance"));
                } else {
                    System.out.println("Insufficient balance. Operation failed!");
                }
            }
        });
    }
});
```
{% endif %}

**`query` option only works for existing objects.** In other words, it has no effect on objects that haven't been saved to the cloud yet.

The benefit of using `query` option instead of the combination of `{{ baseQueryClassName }}` and `{{ baseObjectName }}` shows up when you have multiple clients trying to update the same field at the same time. The latter way is more cumbersome and may lead to potential problems.

#### Updating Counters

Take Twitter as an example, we need to keep track of how many Likes and Retweets a tweet has gained so far. While a Like or Retweet action can be triggered simultaneously by multiple clients, using `{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Swift" %}save{% endif %}{% if platform_name === "Android" %}saveInBackground{% endif %}` can lead to inaccurate results. To make sure that the total number is stored correctly, LeanCloud allows you to **atomically** increase (or decrease) the value of a number field.

{% if platform_name === "JavaScript" %}
```js
var post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
post.set('likes', 0);
post.save().then(function (todo) {
  post.increment('likes');
  post.fetchWhenSave(true);
  return post.save();
}).then(function (post) {
  // fetchWhenSave is enabled, so the latest value of 'likes' will be returned 
}, function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Post", objectId: "575cf743a3413100614d7d75")
todo.increase("likes", by: 1)
todo.save { result in
    switch result {
    case .success:
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
final AVObject theTodo = AVObject.createWithoutData("Post", "564d7031e4b057f4f3006ad1");
theTodo.put("likes", 0);
theTodo.saveInBackground(new SaveCallback() {
    @Override
    public void done(AVException e) {
        theTodo.increment("likes");
        theTodo.setFetchWhenSave(true);
        theTodo.saveInBackground();
    }
});
```
{% endif %}

You can also increase (or decrease) the value of a field by any amount by passing in a second argument to `increment`. When no amount is specified, **1** is used by default.

#### Updating Arrays

There are several operations that can be used to atomically update an array associated with a given key:

{% if platform_name === "JavaScript" %}
- `AV.Object.add('arrayKey', value)`<br/>appends the given object to the end of an array.
- `AV.Object.addUnique('arrayKey', value)`<br/>adds the given object into an array only if it is not in it. The position inserted is not guaranteed.
- `AV.Object.remove('arrayKey', value)`<br/>removes all instances of the given object from an array.
{% endif %}
{% if platform_name === "Swift" %}
- `append(String, element: LCType)`<br/>appends the given object to the end of an array.
- `append(String, element: LCType, unique: Bool)`<br/>appends the given object to the end of an array. A `bool` can be specified for `unique` to make sure the object doesn't repeat itself within the array.
- `append(String, element: [LCType])`<br/>appends the given array of objects to the end of an array.
- `append(String, element: [LCType], unique: Bool)`<br/>appends the given array of objects to the end of an array. A `bool` can be specified for `unique` to make sure the array of objects doesn't repeat itself within the array.
- `remove(String, element: LCType)`<br/>removes all instances of the given object from an array.
- `remove(String, element: [LCType])`<br/>removes all instances of the given array of objects from an array.
{% endif %}
{% if platform_name === "Android" %}
- `add()`<br/>appends the given object to the end of an array.
- `addUnique()`<br/>adds the given object into an array only if it is not in it. The position inserted is not guaranteed.
- `removeAll()`<br/>removes all instances of the given object from an array.
{% endif %}

For example, Todo has a field named **alarms** for keeping track of times at which a user wants to be alerted. The following code adds the times to the alarms field:

{% if platform_name === "JavaScript" %}
```js
var alarm1 = new Date('2018-04-30T07:10:00');
var alarm2 = new Date('2018-04-30T07:20:00');
var alarm3 = new Date('2018-04-30T07:30:00');

var alarms = [alarm1, alarm2, alarm3];

var todo = new AV.Object('Todo');
todo.addUnique('alarms', alarms);
todo.save().then(function (todo) {
  console.log(todo.id);
}, function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func dateWithString(string: String) -> LCDate {
    let dateFormatter = NSDateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
    dateFormatter.locale = NSLocale(localeIdentifier: "en_US_POSIX")
    let date = LCDate(dateFormatter.dateFromString(string)!)
    return date
}
func testSetArray() {
    let todo = LCObject(className: "Todo")
    let alarm1 = dateWithString("2018-04-30 07:10:00")
    let alarm2 = dateWithString("2018-04-30 07:20:00")
    let alarm3 = dateWithString("2018-04-30 07:30:00")
    todo.set("alarms", value: [alarm1, alarm2, alarm3])
    todo.save()
    let alarm4 = dateWithString("2018-04-30 07:40:00")
    todo.append("alarms", element: alarm4, unique: true)
    todo.save { result in
        switch result {
        case .success:
            break
        case .failure(let error):
            print(error)
        }
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    Date date = dateFormat.parse(dateString);
    return date;
}
void addReminders() {
    Date alarm1 = getDateWithDateString("2018-04-30 07:10:00");
    Date alarm2 = getDateWithDateString("2018-04-30 07:20:00");
    Date alarm3 = getDateWithDateString("2018-04-30 07:30:00");

    AVObject todo = new AVObject("Todo");
    todo.addAllUnique("alarms", Arrays.asList(alarm1, alarm2, alarm3));
    todo.saveInBackground();
}
```
{% endif %}

{# Note that it is not currently possible to atomically add and remove items from an array in the same save. You will have to call `save` in between every different kind of array operation. #}

### Destroying Objects

The following code deletes a Todo object from the cloud:

{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '57328ca079bc44005c2472d0');
todo.destroy().then(function (success) {
  // The object is successfully deleted
}, function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "575cf743a3413100614d7d75")
todo.delete { result in
    switch result {
    case .success:
        // The object is successfully deleted
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
todo.deleteInBackground();
```
{% endif %}

You can delete a given field of an object with the `{% if platform_name === "JavaScript" %}unset{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}{# TODO #}{% endif %}` method:

{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '57328ca079bc44005c2472d0');

// The content field will be empty
todo.unset('content');

// Save the object to the cloud
// If the object's field is an array, call save after every unset operation.
todo.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

{# Please note that use of `object.set(null)` to remove a field from an object is not recommended and will result in unexpected functionality. #}

{% call docs.alertWrap() %}
Removing data from the cloud should always be dealt with great caution as it may lead to non-recoverable data loss. We strongly advise that you read [ACL Guide](acl-guide.html) to fully understand the risks. You should also consider implementing Class-level, Object-level, and Field-level permissions for your Classes in the cloud to guard against unauthorized data operations.
{% endcall %}

### Batch Processing

You can create, save, delete, or fetch multiple objects within a single request:

{% if platform_name === "JavaScript" %}
```js
// Create an array for storing AV.Objects
var objects = [];

// Batch create/save
AV.Object.saveAll(objects).then(function (objects) {
  // Success
}, function (error) {
  // Error handling
});

// Batch delete
AV.Object.destroyAll(objects).then(function () {
  // Success
}, function (error) {
  // Error handling
});

// Batch fetch
AV.Object.fetchAll(objects).then(function (objects) {
  // Success
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Batch create/save
saveAll()
saveAllInBackground()

// Batch delete
deleteAll()
deleteAllInBackground()

// Batch fetch
fetchall()
fetchAllInBackground()
```
{% endif %}

The following code sets **isComplete** of all the todos to be **true**:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.find().then(function (todos) {
  // Get a collection of todos to work on
  todos.forEach(function (todo) {
    // Update value
    todo.set('isComplete', true);
  });
  // Save all at once
  return AV.Object.saveAll(todos);
}).then(function (todos) {
  // Success
}, function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        ArrayList<AVObject> todos = (ArrayList<AVObject>) list;
        for (AVObject todo : list) {
            todo.put("status", 1);
        }
        AVObject.saveAllInBackground(todos, new SaveCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {
                    // Success
                } else {
                    // Error handling
                }
            }
        });
    }
});
```
{% endif %}

`saveAll` and `fetchAll` send as many requests behind the scene as the number of objects in the collection, while `deleteAll` completes everything in a single network request. {# TODO: Please refer to the [Calculation of API Calls](faq.html#calculation-of-api-calls) for more details. #}

### Data Models

Objects may have relationships with other objects. For example, in a blogging application, a Post object may have many Comment objects. LeanCloud supports three kinds of relationships, including one-to-one, one-to-many, and many-to-many.

#### One-to-One and One-to-Many Relationships

One-to-one and one-to-many relationships are modeled by saving `{{ baseObjectName }}` as a value in the other object. For example, each Comment in a blogging app might correspond to one Post.

The following code creates a new Post with a single Comment:

{% if platform_name === "JavaScript" %}
```js
// Create a post
var post = new AV.Object('Post');
post.set('title', 'I am starving!');
post.set('content', 'Hmmm, where should I go for lunch?');

// Create a comment
var comment = new AV.Object('Comment');
comment.set('content', 'KFC is the best!');

// Add the post as a property of the comment
comment.set('parent', post);

// This will save both post and comment
comment.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Create a post
let post = AVObject(className: "Post")
post["title"] = "I am starving!"
post["content"] = "Hmmm, where should I go for lunch?"

// Create a comment
let comment = AVObject(className: "Comment")
comment["content"] = "KFC is the best!"

// Add the post as a property of the comment
comment["parent"] = post

// This will save both post and comment
comment.save()
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Create a post
AVObject post = new AVObject("Post");
post.put("title", "I am starving!");
post.put("content", "Hmmm, where should I go for lunch?");

// Create a comment
AVObject comment = new AVObject("Comment");
comment.put("content", "KFC is the best!");

// Add the post as a property of the comment
comment.put("parent", post);

// This will save both post and comment
comment.saveInBackground();
```
{% endif %}

Internally, the backend will store the referred-to object with the Pointer type in just one place in order to maintain consistency. You can also link objects using their objectIds like this:

{% if platform_name === "JavaScript" %}
```js
var post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
comment.set('parent', post);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let post = LCObject(className: "Post", objectId: "575cf743a3413100614d7d75")
comment.set("parent", post)
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVObject post = AVObject.createWithoutData("Post", "558e20cbe4b060308e3eb36c");
comment.put("parent", post);
```
{% endif %}

When an object is fetched, the related `{{ baseObjectName }}`s of it will not be fetched unless they are explicitly specified:

{% if platform_name === "JavaScript" %}
```js
var commentQuery = new AV.Query('Comment');
commentQuery.first().then(function (comment) {
  var parentPost = comment.get('parent');
  parentPost.fetch().then(function (post) {
    var title = post.get('title');
  });
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Comment")
query.getFirst { result in
    switch result {
    case .success(let comment):
        comment.fetch { result in
            switch result {
            case .success:
                print(comment.get("title"))
            case .failure(let error):
                print(error)
            }
        }
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Comment");
query.getFirstInBackground(new GetCallback<AVObject>() {
    @Override
    public void done(AVObject avObject, AVException e) {
        avObject.fetchInBackground(new FetchCallback<AVObject>() {
            @Override
            public void done(AVObject avObject, AVException e) {
                String title = avObject.getString("title");
            }
        });
    }
});
```
{% endif %}

See [Relational Queries](#relational-queries) for more examples.

#### Many-to-Many Relationships

The easiest way to model many-to-many relationships is to use **Arrays**. In most cases, using Arrays helps you reduce the number of queries you need to make and leads to a better performance. However, if additional properties need to be attached to the relationships between two Classes, using **Join Tables** would be a better choice. Keep in mind that the additional properties are used to describe the relationships between Classes rather than any single Class.

We recommend you to use Join Tables if the total amount of objects of any Class exceeds 100.

{% call docs.noteWrap() %}
Modeling relationships among data could be a tough work. We have written a dedicated article to address [Data Modeling](data-modeling.html) in greater detail, which we highly recommend you reading.
{% endcall %}

## Queries

We've already seen how you can retrieve a single object from the cloud with `{{ baseObjectName }}`, but it doesn't seem to be powerful enough when you need to retrieve multiple objects that match certain conditions at once. In such situation, `{{ baseQueryClassName }}` would be a more efficient tool you can use.

{# Before you continue, familiarize yourself with the models that are used in this guide. #}

### Basic Queries

The general steps of performing a basic query include:

1. Creating `{{ baseQueryClassName }}`.
2. Putting conditions on it.
3. Retrieving an array of objects matching the conditions.

The code below retrieves all the students whose last name is "Smith":

{% if platform_name === "JavaScript" %}
```js
var Student = AV.Object.extend('Student');
var query = new AV.Query(Student);
query.equalTo('lastname', 'Smith');
query.find().then(function (results) {
  console.log('Successfully retrieved ' + results.length + ' records.');
}).catch(function (error) {
  console.log('Error: ' + error.code + ' ' + error.message);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Student")
query.whereKey("lastname", .EqualTo("Smith"))
query.find { result in
    switch result {
    case .success(let objects):
        print(objects)
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Student");
query.whereEqualTo("lastname", "Smith");
query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        if (e == null) {
            // Success
        } else {
            // Error handling
        }
    }
});
```
{% endif %}

### Query Constraints

There are several ways to put constraints on the objects found by `{{ baseObjectName }}`.

The code below filters out objects with "Jack" as first name:

{% if platform_name === "JavaScript" %}
```js
query.notEqualTo('firstname', 'Jack');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("firstname", .NotEqualTo("Jack"))
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.whereNotEqualTo("firstname", "Jack");
```
{% endif %}

For sortable types like numbers and strings, you can use comparisons in queries:

{% if platform_name === "JavaScript" %}
```js
// Restricts to age < 18
query.lessThan('age', 18);

// Restricts to age <= 18
query.lessThanOrEqualTo('age', 18);

// Restricts to age > 18
query.greaterThan('age', 18);

// Restricts to age >= 18
query.greaterThanOrEqualTo('age', 18);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Restricts to age < 18
query.whereKey("age", .LessThan(18));

// Restricts to age <= 18
query.whereKey("age", .LessThanOrEqualTo(18));

// Restricts to age > 18
query.whereKey("age", .GreaterThan(18));

// Restricts to age >= 18
query.whereKey("age", .GreaterThanOrEqualTo(18));
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Restricts to age < 18
query.whereLessThan("age", 18);

// Restricts to age <= 18
query.whereLessThanOrEqualTo("age", 18);

// Restricts to age > 18
query.whereGreaterThan("age", 18);

// Restricts to age >= 18
query.whereGreaterThanOrEqualTo("age", 18);
```
{% endif %}

You can apply multiple constraints to a single query, and objects will only be in the results if they match all of the constraints. In other words, it's like an **AND** of constraints.

{% if platform_name === "JavaScript" %}
```js
query.equalTo('firstname', 'Jack');
query.greaterThan('age', 18);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("firstname", .EqualTo("Jack"))
query.whereKey("age", .GreaterThan(18))
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.whereEqualTo("firstname", "Jack");
query.whereGreaterThan("age", 18);
```
{% endif %}

You can limit the number of results by setting `limit`. By default, results are limited to 100.

{% if platform_name === "JavaScript" %}
```js
query.limit(10); // Limit to at most 10 results
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.limit = 10 // Limit to at most 10 results
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.limit(10); // Limit to at most 10 results
```
{% endif %}

{% call docs.noteWrap() %}
For performance reasons, the maximum limit allowed is 1,000, meaning LeanCloud would only return 1,000 results even the limit is set to be greater than 1,000.
{% endcall %}

If you need exactly one result, you may use `{% if platform_name === "JavaScript" %}first{% endif %}{% if platform_name === "Swift" %}getFirst{% endif %}{% if platform_name === "Android" %}getFirstInBackground{% endif %}` for convenience:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.equalTo('priority', 2);
query.first().then(function (data) {
  // data is the first AV.Object satisfying conditions
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("priority", .EqualTo(2))
query.getFirst { result in
    switch result {
    case .success(let todo):
        // todo is the first AVObject satisfying conditions
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("priority", 2);
query.getFirstInBackground(new GetCallback<AVObject>() {
    @Override
    public void done(AVObject avObject, AVException e) {
        if (e == null) {
            // avObject is the first AVObject satisfying conditions
        } else {
            // Error handling
        }
    }
});
```
{% endif %}

You can skip certain number of results by setting `skip`:

{% if platform_name === "JavaScript" %}
```js
query.skip(10); // Skip the first 10 results
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.skip = 10 // Skip the first 10 results
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.skip(10); // Skip the first 10 results
```
{% endif %}

You can implement pagination on your app by using `skip` together with `limit`:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
var now   = new Date();
query.lessThanOrEqualTo('updatedAt', now);
query.limit(10); // Limit to at most 10 results
query.skip(20); // Skip the first 20 records
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("priority", .EqualTo(0))
query.limit = 10 // Limit to at most 10 results
query.skip = 20 // Skip the first 20 records
query.find { result in
    switch result {
    case .success(let todos):
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
Date now = new Date();
query.whereLessThanOrEqualTo("createdAt", now);
query.limit(10); // Limit to at most 10 results
query.skip(20); // Skip the first 20 records
```
{% endif %}

But in reality, the higher the `skip` goes, the slower the query will run. You may consider using **createdAt** or **updatedAt** (which are indexed) to set the range boundaries for large datasets more efficiently. {# , or using the last value returned from an auto-increment field along with `limit` for the purpose of pagination #}

For sortable types, you can control the order in which results are returned:

{% if platform_name === "JavaScript" %}
```js
// Sorts the results in ascending order by the createdAt property
query.ascending('createdAt');

// Sorts the results in descending order by the createdAt property
query.descending('createdAt');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Sorts the results in ascending order by the createdAt property
query.whereKey("createdAt", .Ascending)

// Sorts the results in descending order by the createdAt property
query.whereKey("createdAt", .Descending)
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Sorts the results in ascending order by the createdAt property
query.orderByAscending("createdAt");

// Sorts the results in descending order by the createdAt property
query.orderByDescending("createdAt");
```
{% endif %}

You can even attach multiple sorting rules to a single query:

{% if platform_name === "JavaScript" %}
```js
query.addAscending('priority');
query.addDescending('createdAt');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("priority", .Ascending)
query.whereKey("createdAt", .Descending)
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.addAscendingOrder("priority");
query.addDescendingOrder("createdAt");
```
{% endif %}

To retrieve objects that have or do not have particular fields:

{% if platform_name === "JavaScript" %}
```js
// Finds objects that have the 'image' field
query.exists('image');

// Finds objects that don't have the 'image' field
query.doesNotExist('image');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Finds objects that have the 'image' field
query.whereKey("image", .Existed)

// Finds objects that don't have the 'image' field
query.whereKey("image", .NotExisted)
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Finds objects that have the 'image' field
query.whereExists("images");

// Finds objects that don't have the 'image' field
query.whereDoesNotExist("images");
```
{% endif %}

You can use the `{% if platform_name === "JavaScript" %}matchesKeyInQuery{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}{# TODO #}{% endif %}` method to look for objects with values of fields matching those of objects returned by another query.

For example, if you have a Country Class matching countries with languages and a Student Class matching students with their nationalities:

country | language
---|---
UK  | English
US | English
China | Chinese

fullname | nationality
---|---
John Doe | US
Tom Sawyer  | UK
Ming Li | China

The following code looks for all the students who are from English-speaking countries:

{% if platform_name === "JavaScript" %}
```js
var studentQuery = new AV.Query('Student');
var countryQuery = new AV.Query('Country')
// Get all English-speaking countries
countryQuery.equalTo('language', 'English');
// Match Student's nationality with Country's country
studentQuery.matchesKeyInQuery('nationality', 'country', countryQuery);
studentQuery.find().then(function (results) {
  console.log(results);
  // John Doe & Tom Sawyer are returned
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```jave
{# TODO #}
```
{% endif %}

You can restrict the fields returned by calling `select` with a list of keys. To retrieve todos that contain only the **title** and **priority** fields (and also special built-in fields such as **objectId**, **createdAt**, and **updatedAt**):

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.select(['title', 'priority']);
query.first().then(function (results) {
  // Each of the results will only have the selected fields available
  console.log(todo.get('title')); // √
  console.log(todo.get('content')); // √
  console.log(todo.get('location')); // undefined
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("title", .Selected)
query.whereKey("content", .Selected)
query.find { result in
    switch result {
    case .success(let todos):
        guard let todo = todos.first else { return }
        // Each of the results will only have the selected fields available
        let title   = todo.get("title") // √
        let content = todo.get("content") // √
        let location = todo.get("location") // nil
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.selectKeys(Arrays.asList("title", "content"));
query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        for (AVObject avObject : list) {
            // Each of the results will only have the selected fields available
            String title = avObject.getString("title"); // √
            String content = avObject.getString("content"); // √
            String location = avObject.getString("location"); // Error
        }
    }
});
```
{% endif %}

The unselected fields can be fetched later by calling `{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}fetchInBackground{% endif %}` on the returned objects:

{% if platform_name === "JavaScript" %}
```js
query.first().then(function (results) {
  // Only the selected fields of the object are available here
  return results.fetch();
}).then(function (results) {
  // All the fields of the object are available here
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        for (AVObject avObject : list) {
            // Only the selected fields of the object are available here
            avObject.fetchInBackground(new FetchCallback<AVObject>() {
                @Override
                public void done(AVObject avObject, AVException e) {
                    // All the fields of the object are available here
                }
            })
        }
    }
});
```
{% endif %}

### Queries on String Values

Use `{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Swift" %}PrefixedBy{% endif %}{% if platform_name === "Android" %}whereStartsWith{% endif %}` to restrict to string values that start with a particular string. Similar to a SQL `LIKE` operator, it is indexed so it is efficient for large datasets.

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
// SQL equivalent: title LIKE 'lunch%' 
query.startsWith('title', 'lunch');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
// SQL equivalent: title LIKE 'lunch%' 
query.whereKey("title", .PrefixedBy("lunch"))
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
// SQL equivalent: title LIKE 'lunch%' 
query.whereStartsWith("title", "lunch");
```
{% endif %}

Use `{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Swift" %}MatchedSubstring{% endif %}{% if platform_name === "Android" %}whereContains{% endif %}` to restrict to string values that contain a particular string.

{% if platform_name === "JavaScript" %}
```js
// SQL equivalent: title LIKE '%lunch%'
query.contains('title', 'lunch');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// SQL equivalent: title LIKE '%lunch%'
query.whereKey("title", .MatchedSubstring("lunch"))
```
{% endif %}
{% if platform_name === "Android" %}
```java
// SQL equivalent: title LIKE '%lunch%'
query.whereContains("title", "lunch");
```
{% endif %}

Unlike `{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Swift" %}PrefixedBy{% endif %}{% if platform_name === "Android" %}whereStartsWith{% endif %}`, `{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Swift" %}MatchedSubstring{% endif %}{% if platform_name === "Android" %}whereContains{% endif %}` can't take advantage of indexes, which is not encouraged to be used for large datasets.

{% call docs.noteWrap() %}
Please note that both `{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Swift" %}PrefixedBy{% endif %}{% if platform_name === "Android" %}whereStartsWith{% endif %}` and `{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Swift" %}MatchedSubstring{% endif %}{% if platform_name === "Android" %}whereContains{% endif %}` perform **case-sensitive** matching, so the examples above will not look for string values containing "Lunch", "LUNCH", etc.
{% endcall %}

If you are looking for string values that do not contain a particular string, use `matches` with regular expression:

{% if platform_name === "JavaScript" %}
<pre><code class="lang-js">var query = new AV.Query('Todo');
// 'title' without 'ticket' (case-insensitive)
var regExp = new RegExp('{{ data.regex(true) | safe }}, 'i');
query.matches('title', regExp);
</code></pre>
{% endif %}
{% if platform_name === "Swift" %}
<pre><code class="lang-swift">let query = LCQuery(className: "Todo")
// 'title' without 'ticket' (case-insensitive)
query.whereKey("title", .MatchedPattern("{{ data.regex() | safe }}, option: nil))
</code></pre>
{% endif %}
{% if platform_name === "Android" %}
<pre><code class="lang-java">AVQuery<AVObject> query = new AVQuery<>("Todo");
// 'title' without 'ticket' (case-insensitive)
query.whereMatches("title","{{ data.regex() | safe }});
</code></pre>
{% endif %}

{# 2016-12-29 DO NOT USE markdown to rewrite the previous block #}

However, performing queries with regular expressions as constraints can be very expensive, especially for classes with over 100,000 records. {# LeanCloud restricts how many such operations can be run on a particular app at any given time. #} The reason behind is that queries like this can't take advantage of indexes and will lead to exhaustive scanning of the whole dataset to find the matching objects. We recommend that you take a look at our [In-App Searching](#in-app-searching) feature, a full-text search solution we provide to improve your app's searching ability and user experience.

{% call docs.noteWrap() %}
If you are facing performance issues with queries, please refer to [Optimizing Performance](#optimizing-performance) for possible workarounds and best practices.
{% endcall %}

### Queries on Array Values

The code below looks for all the objects with 2 as an element of its array field "priority":

{% if platform_name === "JavaScript" %}
```js
query.equalTo('priority', 2);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("priority", .EqualTo(2))
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.whereEqualTo("priority", 2);
```
{% endif %}

You can also look for objects whose array field "priority" contains 2, 3, **and** 4:

{% if platform_name === "JavaScript" %}
```js
query.containsAll('priority', [2, 3, 4]);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("priority", .ContainedAllIn([2, 3, 4]))
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.whereContainsAll("priority", Arrays.asList(2, 3, 4));
```
{% endif %}

To retrieve objects whose field matches any one of the values in a given list, you can use `{% if platform_name === "JavaScript" %}containedIn{% endif %}{% if platform_name === "Swift" %}ContainedIn{% endif %}{% if platform_name === "Android" %}whereContainedIn{% endif %}` instead of performing multiple queries. The code below retrieves todo items with "priority" to be 1 **or** 2:

{% if platform_name === "JavaScript" %}
```js
// Single query
priorityOneOrTwo.containedIn('priority', [1, 2]);
// Mission completed :)

// ---------------
//       vs.
// ---------------

// Multiple queries
var priorityOne = new AV.Query('Todo');
priorityOne.equalTo('priority', 1);

var priorityTwo = new AV.Query('Todo');
priorityTwo.equalTo('priority', 2);

var priorityOneOrTwo = AV.Query.or(priorityOne, priorityTwo);
// Kind of verbose :(
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Single query
query.whereKey("priority", .ContainedIn([1, 2]))
// Mission completed :)

// ---------------
//       vs.
// ---------------

// Multiple queries
let priorityOne = LCQuery(className: "Todo")
priorityOne.whereKey("priority", .EqualTo(1))

let priorityTwo = LCQuery(className: "Todo")
priorityTwo.whereKey("priority", .EqualTo(2))

let priorityOneOrTwo = priorityOne.or(priorityTwo)
// Kind of verbose :(
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Single query
query.whereContainedIn("priority", Arrays.asList(1, 2));
// Mission completed :)

// ---------------
//       vs.
// ---------------

// Multiple queries
final AVQuery<AVObject> priorityOne = new AVQuery<>("Todo");
priorityOne.whereEqualTo("priority", 1);

final AVQuery<AVObject> priorityTwo = new AVQuery<>("Todo");
priorityTwo.whereEqualTo("priority", 2);

AVQuery<AVObject> priorityOneOrTwo = AVQuery.or(Arrays.asList(priorityOne, priorityTwo));
// Kind of verbose :(
```
{% endif %}

Conversely, you can use `{% if platform_name === "JavaScript" %}notContainedIn{% endif %}{% if platform_name === "Swift" %}NotContainedIn{% endif %}{% if platform_name === "Android" %}whereNotContainedIn{% endif %}` if you want to retrieve objects that do not match any of the values in a list.

### Relational Queries

There are several ways to perform queries for relational data. To retrieve objects whose given field matches a particular `{{ baseObjectName }}`, you can use `{% if platform_name === "JavaScript" %}equalTo{% endif %}{% if platform_name === "Swift" %}EqualTo{% endif %}{% if platform_name === "Android" %}whereEqualTo{% endif %}` just like how you use it for other data types. For example, if each Comment has a Post object in its "post" field, you can fetch all the comments for a particular Post with the following code:

{% if platform_name === "JavaScript" %}
```js
var post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
var query = new AV.Query('Comment');
query.equalTo('post', post);
query.find().then(function (comments) {
  // comments now contains the comments for the post
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let post = LCObject(className: "Post", objectId: "575cf743a3413100614d7d75")
let query = LCQuery(className: "Comment")
query.whereKey("post", .EqualTo(post))
query.find { result in
    switch result {
    case .success(let comments):
        // comments now contains the comments for the post
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVObject post = AVObject.createWithoutData("Post", "558e20cbe4b060308e3eb36c");
AVQuery<AVObject> query = new AVQuery<>("Comment");
query.whereEqualTo("post", post);
query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        // list now contains the comments for the post
    }
});
```
{% endif %}

To retrieve objects whose given field contains `{{ baseObjectName }}` that matches a different query, you can use `{% if platform_name === "JavaScript" %}matchesQuery{% endif %}{% if platform_name === "Swift" %}MatchedQuery{% endif %}{% if platform_name === "Android" %}whereMatchesQuery{% endif %}`. The code below looks for all the comments for posts with images:

{% if platform_name === "JavaScript" %}
```js
var Post    = AV.Object.extend('Post');
var Comment = AV.Object.extend('Comment');

var innerQuery = new AV.Query(Post);
innerQuery.exists('image');

var query = new AV.Query(Comment);
query.matchesQuery('post', innerQuery);

query.find().then(function (comments) {
  // comments now contains the comments for posts with images
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let innerQuery = LCQuery(className: "Post")
innerQuery.whereKey("image", .Existed)

let query = LCQuery(className: "Comment")
query.whereKey("post", .MatchedQuery(innerQuery))

query.find { result in
    switch result {
    case .success(let comments):
        // comments now contains the comments for posts with images
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> innerQuery = new AVQuery<>("Post");
innerQuery.whereExists("image");

AVQuery<AVObject> query = new AVQuery<>("Comment");
query.whereMatchesQuery("post", innerQuery);

query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        // list now contains the comments for posts with images
    }
});
```
{% endif %}

To retrieve objects whose given field does not contain `{{ baseObjectName }}` that matches a different query, use `{% if platform_name === "JavaScript" %}doesNotMatchQuery{% endif %}{% if platform_name === "Swift" %}NotMatchedQuery{% endif %}{% if platform_name === "Android" %}whereDoesNotMatchQuery{% endif %}` instead.

Sometimes you may need to look for related objects from different classes without extra queries. In such situations, you can use `{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Swift" %}Included{% endif %}{% if platform_name === "Android" %}include{% endif %}` on the same query. The following code retrieves the last 10 comments together with the posts related to them:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Comment');

// Retrieve the most recent ones
query.descending('createdAt');

// Only retrieve the last ten
query.limit(10);

// Include the related post together with each comment
query.include('post');

query.find().then(function (comments) {
  // comments now contains the last ten comments including the "post" associated with each
  for (var i = 0; i < comments.length; i++) {
    // This does not require a network access
    var post = comments[i].get('post');
  }
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Comment")

// Retrieve the most recent ones
query.whereKey("createdAt", .Descending)

// Only retrieve the last ten
query.limit = 10

// Include the related post together with each comment
query.whereKey("post", .Included)

query.find { result in
    switch result {
    case .success(let comments):
        // comments now contains the last ten comments including the "post" associated with each
        guard let comment = comments.first else { return }
        // This does not require a network access
        let post = comment.get("post") as? LCObject
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Comment");

// Retrieve the most recent ones
query.orderByDescending("createdAt");

// Only retrieve the last ten
query.limit(10);

// Include the related post together with each comment
query.include("post");

query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        // list now contains the last ten comments including the "post" associated with each
        for (AVObject comment : list) {
            // This does not require a network access
            AVObject post = comment.getAVObject("post");
        }
    }
});
```
{% endif %}

You can even indicate multi-level associations using dot notations. If you wanted to include the post for each comment as well as the author of the post, you can do:

{% if platform_name === "JavaScript" %}
```js
query.include('post.author');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("post.author", .Included)
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.include("post.author");
```
{% endif %}

Feel free to use `{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Swift" %}Included{% endif %}{% if platform_name === "Android" %}include{% endif %}` as many times as you need for the same query to have multiple fields included. This functionality also works with `{{ baseQueryClassName }}` helpers like `{% if platform_name === "JavaScript" %}first{% endif %}{% if platform_name === "Swift" %}getFirst{% endif %}{% if platform_name === "Android" %}getFirstInBackground{% endif %}` and `get`.

{% call docs.noteWrap() %}
Multi-level conditions passed into `{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Swift" %}Included{% endif %}{% if platform_name === "Android" %}include{% endif %}` won't work with any `{{ baseObjectName }}` contained in an array field. The furthest level that can be reached is the field itself.
{% endcall %}

You can also use dot notations with `{% if platform_name === "JavaScript" %}select{% endif %}{% if platform_name === "Swift" %}Selected{% endif %}{% if platform_name === "Android" %}selectKeys{% endif %}` to limit the fields returned from the related objects:

{% if platform_name === "JavaScript" %}
```js
query.select('post.author.firstname');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("post.author.firstname", .Selected)
```
{% endif %}
{% if platform_name === "Android" %}
```java
query.selectKeys(Arrays.asList("post.author.firstname"));
```
{% endif %}

#### Caveats about Relational Queries

The backend of LeanCloud is not built on relational databases, which makes it impossible to join tables while querying. For the relational queries mentioned above, what LeanCloud would do is to first perform an inner query (with 100 as default limit and 1,000 as maximum) and then insert the result from this query into the outer query. If more than 100 records are returned as the result of the inner query and the outer query contains other constraints, the amount of the records returned in the end could be zero or less than your expectation since only 100 records would be inserted into the outer query.

The following actions can be taken to solve the problem:

- Make sure the number of records in the result of the inner query is no more than 100. If it is between 100 and 1,000, add 1,000 as the limit of the inner query.
- Create redundancy for the fields being queried by the inner query on the table for the outer query.
- Repeat the same query with different `skip` values until all the records are gone through (performance issue could occur if the value of `skip` gets too big).

### Counting Objects

If you just need to count how many objects match a query, but you do not need to retrieve all the objects that match, you can use `{% if platform_name === "JavaScript" %}count{% endif %}{% if platform_name === "Swift" %}count{% endif %}{% if platform_name === "Android" %}countInBackground{% endif %}` instead of `{% if platform_name === "JavaScript" %}find{% endif %}{% if platform_name === "Swift" %}find{% endif %}{% if platform_name === "Android" %}findInBackground{% endif %}`. For example, to count how many todos have been completed:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.equalTo('isComplete', true);
query.count().then(function (count) {
  console.log(count + "todos completed.");
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("isComplete", .EqualTo(true))
query.count()
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("isComplete", true);
query.countInBackground(new CountCallback() {
    @Override
    public void done(int i, AVException e) {
        if (e == null) {
            Log.d(TAG, i + "todos completed.");
        } else {
            // Error handling
        }
    }
});
```
{% endif %}

### Compound Queries

Compound queries can be used if complex query conditions need to be specified. A compound query is a logical combination ("OR" or "AND") of subqueries.

{% call docs.noteWrap() %}
Note that we do not support GeoPoint or non-filtering constraints (e.g. `near`, `withinGeoBox`, `limit`, `skip`, `ascending`, `descending`, `include`) in the subqueries of a compound query.
{% endcall %}

#### OR-ed Query Constraints

An object will be returned as long as it fulfills any one of the subqueries. The code below looks for all the todos that are either created today or completed today:

{% if platform_name === "JavaScript" %}
```js
var today    = new Date('2018-04-30');
var tomorrow = new Date('2018-05-01');

var createdTodayQuery = new AV.Query('Todo');
createdTodayQuery.greaterThanOrEqualTo('createdAt', today);
createdTodayQuery.lessThan('createdAt', tomorrow);

var completedTodayQuery = new AV.Query('Todo');
completedTodayQuery.equalTo('isComplete', true);
completedTodayQuery.greaterThanOrEqualTo('updatedAt', today);
completedTodayQuery.lessThan('updatedAt', tomorrow);

var query = AV.Query.or(createdTodayQuery, completedTodayQuery)
query.find().then(function (results) {
  console.log(results);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}
let today    = getDateWithDateString("2018-04-30")
let tomorrow = getDateWithDateString("2018-05-01")

let createdTodayQuery = LCQuery(className: "Todo")
createdTodayQuery.whereKey("createdAt", .GreaterThanOrEqualTo(today))
createdTodayQuery.whereKey("createdAt", .LessThan(tomorrow))

let completedTodayQuery = LCQuery(className: "Todo")
completedTodayQuery.whereKey("isComplete", .EqualTo(true))
completedTodayQuery.whereKey("updatedAt", .GreaterThanOrEqualTo(today))
completedTodayQuery.whereKey("updatedAt", .LessThan(tomorrow))

let query = createdTodayQuery.or(completedTodayQuery)
query.find { result in
    switch result {
    case .success(let todos):
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}
Date today    = getDateWithDateString("2018-04-30");
Date tomorrow = getDateWithDateString("2018-05-01");

final AVQuery<AVObject> createdTodayQuery = new AVQuery<>("Todo");
createdTodayQuery.whereGreaterThanOrEqualTo("createdAt", today);
createdTodayQuery.whereLessThan("createdAt", tomorrow);

final AVQuery<AVObject> completedTodayQuery = new AVQuery<>("Todo");
completedTodayQuery.whereEqualTo("isComplete", true);
createdTodayQuery.whereGreaterThanOrEqualTo("updatedAt", today);
createdTodayQuery.whereLessThan("updatedAt", tomorrow);

AVQuery<AVObject> query = AVQuery.or(Arrays.asList(createdTodayQuery, completedTodayQuery));
query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        // list contains todos created today or completed today
    }
});
```
{% endif %}

{% call docs.noteWrap() %}
Queries regarding GeoPoints cannot be present among OR-ed queries.
{% endcall %}

#### AND-ed Query Constraints

The effect of using AND-ed query is the same as adding constraints to `{{ baseQueryClassName }}`:

{% if platform_name === "JavaScript" %}
```js
// Get all completed todos created in April
var query = new AV.Query('Todo');
query.greaterThanOrEqualTo('createdAt', new Date('2018-04-01'));
query.lessThan('createdAt', new Date('2018-05-01'));
query.equalTo('isComplete', true);
query.find().then(function (results) {
  // Get results
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Get all completed todos created in April
let dateFromString: (String) -> Date? = { string in
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter.date(from: string)
}
let query = LCQuery(className: "Todo")
query.whereKey("createdAt", .GreaterThanOrEqualTo(dateFromString("2018-04-01")))
query.whereKey("createdAt", .LessThan(dateFromString("2018-05-01")))
query.whereKey("isComplete", .EqualTo(true))
query.find { result in
    switch result {
    case .success(let todos):
        // Get results
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Get all completed todos created in April
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereGreaterThanOrEqualTo("createdAt", getDateWithDateString("2018-04-01"));
query.whereLessThan("createdAt", getDateWithDateString("2018-05-01"));
query.whereEqualTo("isComplete", true);
  query.findInBackground(new FindCallback<AVObject>() {
      @Override
      public void done(List<AVObject> list, AVException e) {
          // Get results
      }
  });
```
{% endif %}

However, by combining AND-ed queries with OR-ed queries together you can construct complicated query conditions in your program. The code below looks for all the todos created today that either have no location set or have 3 as priority:

{% if platform_name === "JavaScript" %}
```js
var createdTodayQuery = new AV.Query('Todo');
createdTodayQuery.greaterThanOrEqualTo('createdAt', new Date('2018-04-30'));
createdTodayQuery.lessThan('createdAt', new Date('2018-05-01'));

var noLocationQuery = new AV.Query('Todo');
noLocationQuery.doesNotExist('location');

var priority3Query = new AV.Query('Todo');
priority3Query.equalTo('priority', 3);

var query = AV.Query.and(
  createdTodayQuery,
  AV.Query.or(
    noLocationQuery,
    priority3Query
  )
);
query.find().then(function (results) {
  // Get results
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}

let createdTodayQuery = LCQuery(className: "Todo")
createdTodayQuery.whereKey("createdAt", .GreaterThanOrEqualTo(getDateWithDateString("2018-04-30")))
createdTodayQuery.whereKey("createdAt", .LessThan(getDateWithDateString("2018-05-01")))

let noLocationQuery = LCQuery(className: "Todo")
noLocationQuery.whereKey("location", .NotExisted)

let priority3Query = LCQuery(className: "Todo")
priority3Query.whereKey("priority", .EqualTo(3))

let query = createdTodayQuery.and(noLocationQuery.or(priority3Query))
query.find { result in
    switch result {
    case .success(let todos):
        // Get results
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}

final AVQuery<AVObject> createdTodayQuery = new AVQuery<>("Todo");
createdTodayQuery.whereGreaterThanOrEqualTo("createdAt", getDateWithDateString("2018-04-30"));
createdTodayQuery.whereLessThan("createdAt", getDateWithDateString("2018-05-01"));

final AVQuery<AVObject> noLocationQuery = new AVQuery<>("Todo");
noLocationQuery.whereDoesNotExist("location");

final AVQuery<AVObject> priority3Query = new AVQuery<>("Todo");
priority3Query.whereEqualTo("priority", 3);

AVQuery<AVObject> query = AVQuery.and(
    Arrays.asList(
        createdTodayQuery,
        AVQuery.or(
            Arrays.asList(
                noLocationQuery,
                priority3Query
            )
        )
    )
);
query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        // Get results
    }
});
```
{% endif %}

{# 
### Aggregate
### Distinct
#}

{# ### 缓存查询
缓存一些查询的结果到磁盘上，这可以让你在离线的时候，或者应用刚启动，网络请求还没有足够时间完成的时候可以展现一些数据给用户。当缓存占用了太多空间的时候，Cloud storage 会自动清空缓存。

默认情况下的查询不会使用缓存，除非你调用接口明确设置启用。例如，尝试从网络请求，如果网络不可用则从缓存数据中获取，可以这样设置：

{% block code_set_cache_policy %}{% endblock %}

#### 缓存策略
为了满足多变的需求，SDK 默认提供了以下几种缓存策略：

{% block table_cache_policy %}{% endblock %}

#### 缓存相关的操作
{% block code_cache_operation %}{% endblock %} #}

### Optimizing Performance
 
There are several factors that could lead to potential performance issues when you conduct a query, especially when more than 100,000 records are returned at a time. We are listing some common ones here so you can design your apps accordingly to avoid them:

- Querying with "not equal to" or "not include" (index will not work)
- Querying on strings with a wildcard at the beginning of the pattern (index will not work)
- Using `count` with conditions (all the entries will be gone through)
- Using `skip` for a great number of entries (all the entries that need to be skipped will be gone through)
- Sorting without index (querying and sorting cannot share a composite index unless the conditions used on them are both covered by the same one)
- Querying without index (the conditions used on the query cannot share a composite index unless all of them are covered by the same one; additional time will be consumed if excessive data falls under the uncovered conditions)

## Live Queries

A live query is, as its name implies, derived from a normal [`{{ baseQueryClassName }}`](#queries) but has enhanced capability. It allows you to automatically synchronize data changes from one client to other clients without writing complex code, making it suitable for apps that need real-time data.

Suppose you are building an app that allows multiple users to edit the same file at the same time. `{{ baseQueryClassName }}` would not be an ideal tool since it is based on a pull model and you cannot know when to query from the cloud to get the updates.

To solve this problem, we introduced LiveQuery. This tool allows you to subscribe to the `{{ baseQueryClassName }}`s you are interested in. Once subscribed, the cloud will notify clients by generating event messages whenever `{{ baseObjectName }}`s that match the `{{ baseQueryClassName }}` are created or updated, in real-time.

Behind the scene, we use WebSocket connections to have clients and the cloud communicate with each other and maintain the subscription status of clients. In most cases, it isn't necessary to deal with the WebSocket connections directly, so we developed a simple API to help you focus on your business logics rather than technical implementations.

LiveQuery has both free and paid plans. See [Pricing](https://leancloud.cn/pricing/) to learn about your free quota and upgrade options.

### Initializing LiveQuery

LiveQuery is supported by Android SDK v4.2.0+, JavaScript SDK v3.0.0+, and iOS SDK v5.0.0+. To use LiveQuery in your app, go to [Dashboard > Storage > Settings](/dashboard/storage.html?appid={{appid}}#/storage/conf) and check the **Enable LiveQuery** option under the **Misc** section, then include the following code:

{% if platform_name === "JavaScript" %}
```html
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@{{jssdkversion}}/dist/av-live-query-min.js"></script>
```

See [Installing SDK](#installing-sdk) for more details.
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```xml
<!-- RTM modules and push notifications START -->
<!-- Both RTM modules and push notifications need PushService -->
<service android:name="com.avos.avoscloud.PushService"/>
<receiver android:name="com.avos.avoscloud.AVBroadcastReceiver">
  <intent-filter>
    <action android:name="android.intent.action.BOOT_COMPLETED"/>
    <action android:name="android.intent.action.USER_PRESENT"/>
    <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
  </intent-filter>
</receiver>
<!-- RTM modules and push notifications END -->
```

```java
// Initialize the app
AVOSCloud.initialize(this, "{{appid}}", "{{appkey}}");
```
{% endif %}

### Demo

The video here shows the effect of using LiveQuery on the web client and the mobile client of the same app:

{# 2017-06-09 this video is over-sized, put it on qiniu instead of hosting it locally for better performance #}
<div style="border:2px solid #ccc; margin-bottom:1em;">
  <video src="https://lc-lhzo7z96.cn-n1.lcfile.com/1496988080458" controls autoplay muted preload="auto" width="100%" height="100%" >
    HTML5 Video is required for this demo, which your browser doesn't support.
  </video>
</div>

Feel free to try it by yourself with the following steps:

1. Scan the QR code below with WeChat to open the "LeanTodo" mini program:<br/>
   <img src="images/leantodo-weapp-qr.png" width="150" height="150"> 
2. Click on **Settings** > **Account Settings** on the bottom left of the screen, then create an account with a username and a password. You will need the same username and password later.
3. Visit <https://leancloud.github.io/leantodo-vue/> in your browser and enter the same credentials, then click on **Login**.
4. Enter some random data on one client and observe how changes are synchronized to other clients.

{% call docs.noteWrap() %}
Make sure to create your account in the mini program first. If you create your account in the web app, you cannot log in to the same account in the mini program.
{% endcall %}

{% call docs.noteWrap() %}
You may also be interested in watching our [LeanCloud Open Course (Chinese)](http://www.bilibili.com/video/av11291992/) to get yourself familiarized with the basics of the tool.
{% endcall %}

### Creating a Subscription

To make a query *live*, create a normal `{{ baseQueryClassName }}` object, put conditions on it if there are, and then subscribe to it:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Employee');
query.subscribe().then(function (liveQuery) {
  // Query becomes live after getting a subscription
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func subscribe() {
    let query = AVQuery(className: "Employee")
    let liveQuery = AVLiveQuery(query: query)
    liveQuery.delegate = self
    liveQuery.subscribe { (succeeded, error) in
        // Query becomes live after getting a subscription
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Employee");
AVLiveQuery liveQuery = AVLiveQuery.initWithQuery(query);
liveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Query becomes live after getting a subscription
    }
  }
});
```
{% endif %}

Now you will be able to receive updates related to `{{ baseObjectName }}`. If an `Employee` object is created by another client with *Kelly* as `first_name`, the following code can get the new `Employee` for you:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Employee');
query.subscribe().then(function (liveQuery) {
  liveQuery.on('create', function (newEmployee) {
    console.log(newEmployee.get('first_name')); // Kelly
  });
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func subscribe() {
    let query = AVQuery(className: "Employee")
    let liveQuery = AVLiveQuery(query: query)
    liveQuery.delegate = self
    liveQuery.subscribe { (succeeded, error) in
        // Query becomes live after getting a subscription
    }
}
func liveQuery(_ liveQuery: AVLiveQuery, objectDidCreate newEmployee: Any) {
    print(newEmployee.get("first_name")) // Kelly
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Employee");
AVLiveQuery liveQuery = AVLiveQuery.initWithQuery(query);
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectCreated(AVObject newEmployee) {
    System.out.println(newEmployee.getString("first_name")); // Kelly
  }
});
liveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {
  @Override
  public void done(AVException e) {
    if (null == e) {
      // Query becomes live after getting a subscription
    }
  }
});
```
{% endif %}

If someone updates this `Employee` by changing its `team` to *Finance*, the following code can get the updated version for you:

{% if platform_name === "JavaScript" %}
```js
liveQuery.on('update', function (updatedEmployee, updatedKeys) {
  console.log(updatedEmployee.get('team')); // Finance
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidUpdate updatedEmployee: Any, updatedKeys: [String]) {
    print(updatedEmployee.get("team")) // Finance
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectUpdated(AVObject updatedEmployee, List<String> updateKeyList) {
      System.out.println(updatedEmployee.getString("team")); // Finance
  }
});
```
{% endif %}

### Event Handling

The following types of data changes can be monitored once subscription is set up:

- `create`
- `update`
- `enter`
- `leave`
- `delete`
- `login`

#### `create` Event

{% if platform_name === "JavaScript" %}
```js
liveQuery.on('create', function (obj) {
  console.log('Object created.');
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidCreate obj: Any) {
    print("Object created.")
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectCreated(AVObject obj) {
    System.out.println("Object created.");
  }
});
```
{% endif %}

A `create` event will be triggered when a new `{{ baseObjectName }}` is created and it fulfills the `{{ baseQueryClassName }}` you subscribed. The `obj` is the new `{{ baseObjectName }}` being created.

#### `update` Event

{% if platform_name === "JavaScript" %}
```js
liveQuery.on('update', function (obj, updatedKeys) {
  console.log('Object updated.');
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidUpdate obj: Any, updatedKeys: [String]) {
    print("Object updated.")
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectUpdated(AVObject obj, List<String> updateKeyList) {
    System.out.println("Object updated.");
  }
});
```
{% endif %}

An `update` event will be triggered when an existing `{{ baseObjectName }}` fulfilling the `{{ baseQueryClassName }}` you subscribed is updated. The `obj` is the `{{ baseObjectName }}` being updated.

#### `enter` Event

{% if platform_name === "JavaScript" %}
```js
liveQuery.on('enter', function (obj, updatedKeys) {
  console.log('Object entered.');
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidEnter obj: Any, updatedKeys: [String]) {
    print("Object entered.")
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectEnter(AVObject obj, List<String> updateKeyList) {
    System.out.println("Object entered.");
  }
});
```
{% endif %}

An `enter` event will be triggered when an existing `{{ baseObjectName }}`'s old value does not fulfill the `{{ baseQueryClassName }}` you subscribed but its new value does. The `obj` is the `{{ baseObjectName }}` entering the `{{ baseQueryClassName }}` and its content is the latest value of it.

{% call docs.noteWrap() %}
There is a clear distinction between a `create` event and an `enter` event. If an object already exists and later matches the query's conditions, an `enter` event will be triggered. If an object didn't exist already and is later created, a `create` event will be triggered.
{% endcall %}

#### `leave` Event

{% if platform_name === "JavaScript" %}
```js
liveQuery.on('leave', function (obj, updatedKeys) {
  console.log('Object left.');
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidLeave obj: Any, updatedKeys: [String]) {
    print("Object left.")
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectLeave(AVObject obj, List<String> updateKeyList) {
    System.out.println("Object left.");
  }
});
```
{% endif %}

A `leave` event will be triggered when an existing `{{ baseObjectName }}`'s old value fulfills the `{{ baseQueryClassName }}` you subscribed but its new value does not. The `obj` is the `{{ baseObjectName }}` leaving the `{{ baseQueryClassName }}` and its content is the latest value of it.

#### `delete` Event

{% if platform_name === "JavaScript" %}
```js
liveQuery.on('delete', function (obj) {
  console.log('Object deleted.');
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func liveQuery(_ liveQuery: AVLiveQuery, objectDidDelete obj: Any) {
    print("Object deleted.")
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
  @Override
  public void onObjectDeleted(String obj) {
    System.out.println("Object deleted.");
  }
});
```
{% endif %}

A `delete` event will be triggered when an existing `{{ baseObjectName }}` fulfilling the `{{ baseQueryClassName }}` you subscribed is deleted. The `obj` is the `objectId` of the `{{ baseObjectName }}` being deleted.

#### `login` Event

{% if platform_name === "JavaScript" %}
```js
liveQuery.on('login', function (obj) {
  console.log('User logged in.');
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

A `login` event will be triggered when a user successfully logs in to your app. The `obj` is the `{{ userObjectName }}` logged in.

### Unsubscribing

You can cancel a subscription to stop receiving events regarding `{{ baseQueryClassName }}`. After that, you won't get any events from the subscription.

{% if platform_name === "JavaScript" %}
```js
liveQuery.unsubscribe().then(function () {
  // Successfully unsubscribed
}).catch(function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
liveQuery.unsubscribe { (succeeded, error) in
    if succeeded {
        // Successfully unsubscribed
    } else {
        // Error handling
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
liveQuery.unsubscribeInBackground(new AVLiveQuerySubscribeCallback() {
  @Override
  public void done(AVException e) {
    if (null != e) {
      // Successfully unsubscribed
    } else {
      // Error handling
    }
  }
});
```
{% endif %}

### Caveats about LiveQuery

Given the real-time feature of LiveQuery, developers may find it tempting to use it for instant messaging. As LiveQuery is neither designed nor optimized for completing such tasks, we discourage such use of this tool, let alone there will be additional cost for saving message history and rising challenges of code maintenance. We recommend using [our real-time messaging solution](https://leancloud.cn/rtm/) for this scenario.

## Files

`{{ fileObjectName }}` allows you to store application files in the cloud that would otherwise be too large or cumbersome to fit into a regular `{{ baseObjectName }}`. The most common use case is storing images, but you can also use it for documents, videos, music, and any other binary data.

### Creating Files

There are a couple of ways to create a file. You can create a file from a base64-encoded string:

{% if platform_name === "JavaScript" %}
```js
var base64Data = 'Q3VyaW9zaXR5IGtpbGxlZCB0aGUgY2F0IQ==';
var file = new AV.File(
  'resume.txt', // File name
  { base64: base64Data }
);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let data = "My Work Experience".data(using: .utf8) {
    let file = LCFile(payload: .data(data: data))
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVFile file = new AVFile(
  "resume.txt", // File name
  "Working with LeanCloud is great!".getBytes()
);
```
{% endif %}

{% if platform_name === "JavaScript" %}
Alternatively, you can create a file from an array of byte values:

```js
var bytes = [0x6f, 0x2c, 0x20, 0x77];
var file = new AV.File('file.txt', bytes);
```
{% endif %}

It is also possible to create a file from a URL:

{% if platform_name === "JavaScript" %}
```js
var file = AV.File.withURL(
  'LeanCloud.png',
  'https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.2b667fd1.png'
);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let url = URL(string: "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.2b667fd1.png") {
    let file = LCFile(url: url)
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVFile file = new AVFile(
  "LeanCloud.png",
  "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.2b667fd1.png",
  new HashMap<String, Object>()
);
```
{% endif %}

{% call docs.noteWrap() %}
When creating files from URLs, the SDK will not upload the actual files into the cloud but will store the addresses of the files as strings. This will not lead to actual traffic for uploading files, as opposed to creating files in other ways by doing which the files will be actually stored into the cloud.
{% endcall %}

LeanCloud will auto-detect the type of the file you are uploading based on the file extension, but you can specify the **Content-Type** (commonly referred to as MIME type) with a third parameter:

{% if platform_name === "JavaScript" %}
```js
var file = new AV.File(
  'newFile.zzz',
  fileData,
  // Content-Type
  'image/png'
);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

But the most common method for creating files is to upload them from local paths{{ ". In a web app, you can first create an input button in the user interface:" if platform_name === "JavaScript" else ":" }}

{% if platform_name === "JavaScript" %}
```html
<input type="file" id="photoFileUpload" />
```

Then, in a click handler or other function, get a reference to that file:

```js
var fileUploadControl = document.getElementById('photoFileUpload');
if (fileUploadControl.files.length > 0) {
  var localFile = fileUploadControl.files[0];
  var fileName = 'avatar.jpg';

  var file = new AV.File(
    fileName,
    localFile
  );
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let url = Bundle.main.url(forResource: "avatar", withExtension: "jpg") {
    let file = LCFile(payload: .fileURL(fileURL: url))
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVFile file = AVFile.withAbsoluteLocalPath("avatar.jpg", Environment.getExternalStorageDirectory() + "/avatar.jpg");
```
{% endif %}

The file we uploaded here is named *avatar.jpg*. There are a couple of things to note here:

- Each file uploaded will get its unique ID, so it is allowed for multiple files to share the same name.
- A correct extension needs to be assigned to each file which the cloud will use to infer the type of a file. For example, if you are storing a PNG image with `{{ fileObjectName }}`, use `.png` as its extension.
- If the file doesn't have an extension and the `ContentType` parameter is not specified, LeanCloud defaults the file's type to be *application/octet-stream*.

### Saving Files

By saving a file, you store it into the cloud and get a permanent URL pointing to it:

{% if platform_name === "JavaScript" %}
```js
file.save().then(function (file) {
  // The file has been saved to LeanCloud
  console.log(file);
  // mime_type: "application/octet-stream"
  // objectId:  "5aed9c7b7f6fd300387b480d"
  // url:       "https://lc-tvO56WBF.cn-n1.lcfile.com/edfc48a5bd44ba441f9e"
  // ... 
  var originalFileName = file.get('name');
}, function (error) {
  // The file either could not be read or could not be saved to LeanCloud
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
file.save { result in
    switch result {
    case .success:
        break
    case .failure(let error):
        // The file either could not be read or could not be saved to LeanCloud
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
file.saveInBackground(new SaveCallback() {
    @Override
    public void done(AVException e) {
        if (null != e) {
            Log.d(TAG, file.getUrl()); // Get the URL of the file
        } else {
            // The file either could not be read or could not be saved to LeanCloud
        }
    }
});
```
{% endif %}

{% call docs.noteWrap() %}
A file successfully uploaded can be found in the `_File` class and cannot be modified later. If you need to change the file, you have to upload the modified file again and a new ID and URL will be generated.
{% endcall %}

You can associate a file with `{{ baseObjectName }}` after it is saved:

{% if platform_name === "JavaScript" %}
```js
var file = AV.File.withURL(
  'cake-a.jpg',
  'http://www.bakery.com/cake-a.jpg'
);
file.save().then(function (file) {
  var Todo = AV.Object.extend('Todo');
  var todo = new Todo();
  todo.set('title', 'get cakes');
  // attachments is an Array field
  todo.add('attachments', file);
  todo.save();
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
file.save { result in
    switch result {
    case .success:
        let todo = LCObject(className: "Todo")
        todo.set("title", value: "get cakes")
        // attachments is an Array field
        todo.append("attachments", element: file)
        todo.save()
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
file.saveInBackground(new SaveCallback() {
    @Override
    public void done(AVException e) {
        AVObject todo = new AVObject("Todo");
        todo.put("title", "get cakes");
        // attachments is an Array field
        todo.add("attachments", file);
        todo.saveInBackground();
    }
});
```
{% endif %}

{# 2017-11-09 doesn't apply to swift, php, python #}
{% if platform_name === "JavaScript" or platform_name === "Objective-C" or platform_name === "Java" or platform_name === "Android" %}
On a related note, if the files are stored as an array of objects and you want to get them within a single query, you need to use the `{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "Java" or platform_name === "Android" %}include{% endif %}` method with `{{ baseQueryClassName }}`. For example, if you are retrieving all the todos with the same title "get cakes" and you want to retrieve their related attachments at the same time:
{% endif %}

{% if platform_name === "JavaScript" %}
```js
// Get all todos with the same title and contain attachments
var query = new AV.Query('Todo');
query.equalTo('title', 'get cakes');
query.exists('attachments');

// Include attachments with each todo
query.include('attachments');

query.find().then(function (todos) {
  todos.forEach(function (todo) {
    // Get attachments array for each todo
    var attachments = todo.get('attachments');
    attachments.forEach(function (attachment) {
      // Each attachment is an AV.File instance
      if (attachment) {
        console.log('URL of the attachment: ', attachment.get('url'));
      }
    });
  });
});
```
{% endif %}
{% if platform_name === "Objective-C" %}
```objc
{# TODO #}
```
{% endif %}
{% if platform_name === "Java" or platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

### Upload Progress

While uploading, you can leverage the `{% if platform_name === "JavaScript" %}onprogress{% endif %}{% if platform_name === "Swift" %}progress{% endif %}{% if platform_name === "Android" %}ProgressCallback{% endif %}` hook on the `save` method to do whatever you want with the upload progress event:

{% if platform_name === "JavaScript" %}
```js
file.save({
  onprogress: function (event) {
    console.log(event)
    // {
    //   loaded:  1234,
    //   total:   2468,
    //   percent: 50
    // }
  }
}).then(/* ... */);

// The second parameter of save (callbacks) must be present
// if SDK version is below 2.0
file.save({
  onprogress: function (event) {
    console.log(event);
  }
}, {}).then(/* ... */);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
file.save(
    progress: { progress in
        print(progress)
    },
    completion: { result in
        switch result {
        case .success:
            break
        case .failure(let error):
            print(error)
        }
    }
)
```
{% endif %}
{% if platform_name === "Android" %}
```java
file.saveInBackground(new SaveCallback() {
    @Override
    public void done(AVException e) {
        // Things to do after saving
    }
}, new ProgressCallback() {
    @Override
    public void done(Integer integer) {
        // integer is the progress between 0 and 100
    }
});
```
{% endif %}

### File Metadata

When uploading a file, you can specify or retrieve metadata for that file using the `metaData` method. This metadata can contain additional properties you want to put on the file. However, once the upload completes, you cannot update the file any more including its metadata content.

{% if platform_name === "JavaScript" %}
```js
// Set metadata
file.metaData('author', 'LeanCloud');

file.save().then(function (file) {
  // Get all metadata 
  var metadata = file.metaData();
  // Get author
  var author   = file.metaData('author');
  // Get file name
  var fileName = file.get('name');
  // Get size
  // Not available for files created from base64-encoded strings or URLs
  var size     = file.size();
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

{#
### Retrieving File Contents/Download

How to best retrieve the file contents back depends on the context of your application. Because of cross-domain request issues, it's best if you can make the browser do the work for you. Typically, that means rendering the file's URL into the DOM. Here we render an uploaded profile photo on a page with jQuery:

客户端 SDK 接口可以下载文件并把它缓存起来，只要文件的 URL 不变，那么一次下载成功之后，就不会再重复下载，目的是为了减少客户端的流量。

{% block code_download_file %}{% endblock %}
{% block text_download_progress %}请注意代码中**下载进度**数据的读取。{% endblock %}

#}

### Image Thumbnails

You can get the thumbnail of an image without downloading the entire file:

{% if platform_name === "JavaScript" %}
```js
// Get a 100px by 200px (width by height) thumbnail
var url = file.thumbnailURL(100, 200);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Get a 100px by 200px (width by height) thumbnail
String url = file.getThumbnailUrl(true, 100, 200);
```
{% endif %}

{% call docs.noteWrap() %}
Thumbnails cannot be generated for files larger than **20 MB**.
{% endcall %}

{% call docs.alertWrap() %}
Thumbnails are currently only available for apps in the **North China** region.
{% endcall %}

### Deleting Files

The code below deletes a file from the cloud:

{% if platform_name === "JavaScript" %}
```js
// Given that file's objectId is known
var file = AV.File.createWithoutData('552e0a27e4b0643b709e891e');
file.destroy().then(function (success) {
  // File destroyed
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
file.delete { result in
    switch result {
    case .success:
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
file.deleteInBackground(new DeleteCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // File destroyed
        } else {
            // Error handling
        }
    }
});
```
{% endif %}

{% call docs.alertWrap() %}
By default, a file is not allowed to be deleted. You can change the setting by going to [Dashboard > Data > `_File`](/data.html?appid={{appid}}#/_File) and select **Misc** > **Permission Settings** > **delete**.
{% endcall %}

### Enabling HTTPS

If you demand that the files in the cloud should be accessed through HTTPS, check on **Enable HTTPS domain** in [Dashboard > Data > Settings > Files](/dashboard/storage.html?appid={{appid}}#/storage/conf). There is no free quota on using HTTPS for files and you will see the pricing once the function is enabled.

{% call docs.alertWrap() %}
By enabling HTTPS, whether the URLs of the files returned by API use HTTPS or HTTP will be affected. Keep in mind that even the function is not enabled, the clients can still access files with HTTPS URLs which will lead to additional expenditure.
{% endcall %}

After enabling HTTPS, the URLs of the files previously stored in the `_File` table will be converted to HTTPS. If you disable the function, the URLs being converted will not change back.

LeanCloud RTM stores files sent through messages with `{{ fileObjectName }}` and the URLs of the files will be included in the messages. After HTTPS is enabled, the URLs of the files sent in the past messages will not be automatically converted.

{# #### HTTP Support for iOS 9 and Up

Starting iOS 9, Apple requires HTTPS connections for iOS apps and denies HTTP connections by default. All LeanCloud APIs supports HTTPS except for the `getData` method of `AV.File`.

If your app still needs to make HTTP requests, such as when [accessing files in LeanCloud RTM that still reference to insecure domains](#rtm-http-policy), you should add those insecure domains to your project's `Info.plist`:   

Right-click on `Info.plist`, choose **Opened As** > **Source Code**, append the following text to the nodes **plist** > **dict**:

```xml
<key>NSAppTransportSecurity</key>
<dict>
  <key>NSExceptionDomains</key>
  <dict>
    <!-- for US node, replace clouddn.com with amazonaws.com -->
    <key>clouddn.com</key>
    <dict>
      <key>NSIncludesSubdomains</key>
      <true/>
      <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
      <true/>
    </dict>
  </dict>
</dict>
```
Or go to your project's **Target** panel, open the **Info** tab and modify settings there as illustrated below:

![](../images/ios_qiniu_http.png)

#}

### Setting up Custom Domain

LeanCloud offers a shared domain for all the apps to access the files stored in the cloud. However, due to the Cyber Security Law of the countries where we offer our services, the shared domain might not be available all the time. We highly recommend that you **set up your custom domains for accessing files** so that your apps will not be affected when the shared domain becomes unavailable. You can set up custom domains at [Storage > Settings > Files](/dashboard/storage.html?appid={{appid}}#/storage/conf).

### CDN Support

Files stored on LeanCloud are hosted on [content delivery network (CDN)](https://en.wikipedia.org/wiki/Content_delivery_network) for both East China and North China regions.

If your apps aren't running on these regions and you want to speed up delivery of static files for users from different regions, you can follow the instructions below to set up your own CDN.

Take [Amazon CloudFront CDN](https://aws.amazon.com/cloudfront/) as an example:

- Read [Getting Started with CloudFront](http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html).
- Create an Amazon AWS account, and choose a CloudFront subscription plan that suits your business.
- LeanCloud has got S3's read permission properly configured, so you can skip [Step 2: Upload your content to Amazon S3 and grant object permissions](http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html#GettingStartedUploadContent) in the guide and proceed with other steps.
- Take the domain name from the URL of your `{{ fileObjectName }}` and fill it into the CloudFront's **Origin Domain Name**. Leave the other settings with defaults.

{% if platform_name === "JavaScript" %}
## Promises

Each asynchronous method in LeanCloud JavaScript SDK returns a `Promise` which can be used to handle the completion and exception of the method.

```js
// This is a complete example of Promise
// Update an AV.Object after it is being queried
var query = new AV.Query('TestObject');
query.equalTo('name', 'hjiang');
// find is asynchronous which gives back a Promise that then can be called on
query.find().then(function (results) {
  // Returns a list of objects
  var obj = results[0];
  obj.set('phone', '182xxxx5548');
  // save is also asynchronous which gives back a Promise that you can return here and chain another Promise afterwards
  return obj.save();
}).then(function () {
  // The Promise returned by save method
  console.log('Successfully updated phone number');
}).catch(function (error) {
  // Put catch at the very end of Promise chain which catches all the errors
  console.error(error);
});
```

### The `then` Method

Each Promise has a method called `then` which takes in two callbacks. The first callback is called when the Promise is `resolved` (runs successfully) while the second one is called when the Promise is `rejected` (gets error).

```js
obj.save().then(function (obj) {
  // Successfully saved the object
}, function (error) {
  // Error handling
});
```

The second callback is optional.

You may also implement your logic with `catch`:

```js
obj.save().then(function (obj) {
  // Successfully saved the object
}).catch(function (error) {
  // Error handling
});
```

### Chaining Promises Together

Promise allows you to elegantly connect asynchronous requests together according to the order they should be called. If the callback of a Promise returns another Promise, the callback in the second then will not be resolved unless the one in the first then is resolved. This is also called **Promise Chain**.

```js
// Add contents to the page following the order of chapters
var chapterIds = [
  '584e1c408e450a006c676162', // Chapter One
  '584e1c43128fe10058b01cf5', // Chapter Two
  '581aff915bbb500059ca8d0b'  // Chapter Three
];

new AV.Query('Chapter').get(chapterIds[0]).then(function (chapter0) {
  // Add contents to the page
  addHtmlToPage(chapter0.get('content'));
  // Return the new Promise
  return new AV.Query('Chapter').get(chapterIds[1]);
}).then(function (chapter1) {
  addHtmlToPage(chapter1.get('content'));
  return new AV.Query('Chapter').get(chapterIds[2]);
}).then(function (chapter2) {
  addHtmlToPage(chapter2.get('content'));
  // Done
});
```

### Error Handling with Promises

If any single Promise in the chain throws an error, all the callbacks following it meant for successful operations will be skipped until an error handling callback is encountered.

It is a common practice to attach an error handling function at the end of a Promise chain.

The code above can be rewritten with `try` and `catch` in the following way:

```js
new AV.Query('Chapter').get(chapterIds[0]).then(function (chapter0) {
  addHtmlToPage(chapter0.get('content'));

  // Force an error
  throw new Error('Error');

  return new AV.Query('Chapter').get(chapterIds[1]);
}).then(function (chapter1) {
  // The code here will be ignored
  addHtmlToPage(chapter1.get('content'));
  return new AV.Query('Chapter').get(chapterIds[2]);
}).then(function (chapter2) {
  // The code here will be ignored
  addHtmlToPage(chapter2.get('content'));
}).catch(function (error) {
  // This error handling function will be called, printing out the error message "Error"
  console.error(error.message);
});
```

Further reading on Promises:

- [Promises/A+ Proposal](https://github.com/promises-aplus/promises-spec)
{% endif %}

## GeoPoints

LeanCloud allows you to associate real-world latitude and longitude coordinates with an object by adding `{{ geoPointObjectName }}` to the `{{ baseObjectName }}`. By doing so, queries on the proximity of an object to a given point can be performed, allowing you to easily implement functions like looking for users or places nearby.

To associate a point with an object, you need to create the point first. The code below creates `{{geoPointObjectName}}` with 39.9 as latitude and 116.4 as longitude:

{% if platform_name === "JavaScript" %}
```js
var point = new AV.GeoPoint(
  39.9, // latitude
  116.4 // longitude
);

// Other ways of creating AV.GeoPoint
var point2 = new AV.GeoPoint([39.9, 116.4]);
var point3 = new AV.GeoPoint({ latitude: 39.9, longitude: 116.4 });
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let leancloudOffice = LCGeoPoint(latitude: 39.9, longitude: 116.4)
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVGeoPoint point = new AVGeoPoint(39.9, 116.4);
```
{% endif %}

Now you can store the point in an object as a regular field:

{% if platform_name === "JavaScript" %}
```js
todo.set('location', point);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "575cf743a3413100614d7d75")
todo.set("location", value: leancloudOffice)
```
{% endif %}
{% if platform_name === "Android" %}
```java
todo.put("whereCreated", point);
```
{% endif %}

### Geo Queries

With a number of existing objects with spatial coordinates, you can find out which of them are closest to a given point, or are contained within a particular area. This can be done by adding another restriction to `AV.Query` using `near`. The code below returns a list containing ten places that are closest to a given point:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo'); // Create a query for Todo
var point = new AV.GeoPoint(39.9, 116.4);
query.near('location', point);
query.limit(10); // Limit to 10 closest locations
query.find().then(function (results) {
  var nearbyTodos = results;
}, function (error) {
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo") // Create a query for Todo
let point = LCGeoPoint(latitude: 39.9, longitude: 116.4)
query.whereKey("whereCreated", .LocatedWithin(point))
query.limit = 10 // Limit to 10 closest locations
query.find { result in
    switch result {
    case .success(let todos):
        let todos = result.objects
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo"); // Create a query for Todo
AVGeoPoint point = new AVGeoPoint(39.9, 116.4);
query.whereNear("whereCreated", point);
query.limit(10); // Limit to 10 closest locations
query.findInBackground(new FindCallback<AVObject>() {
    @Override
    public void done(List<AVObject> list, AVException e) {
        List<AVObject> nearbyTodos = list;
    }
});
```
{% endif %}

Note that additional sorting conditions ({% if platform_name === "JavaScript" %}`ascending` or `descending`{% endif %}{% if platform_name === "Swift" %}`.Ascending` or `.Descending`{% endif %}{% if platform_name === "Android" %}`orderByAscending` or `orderByDescending`{% endif %}) applied will gain higher priorities than the default order by distance.

{#
```js
var query = new AV.Query('Todo');
var point = new AV.GeoPoint(39.9, 116.4);
query.withinKilometers('whereCreated', point, 2.0);
```
#}

To have the results limited within a certain distance, check out {% if platform_name === "JavaScript" %}`withinMiles`, `withinKilometers`, and `withinRadians`{% endif %}{% if platform_name === "Swift" %}`LocatedNear`'s `from` and `to` parameters{% endif %}{% if platform_name === "Android" %}`whereWithinMiles`, `whereWithinKilometers`, and `whereWithinRadians`{% endif %} in our API docs.

It's also possible to query for the set of objects that are contained within a particular area. To find the objects in a rectangular bounding box, add the `{% if platform_name === "JavaScript" %}withinGeoBox{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}{# TODO #}{% endif %}` restriction to your `AV.Query`:

<img width="300" height="200" src="images/geopoint-withingeobox.svg" />

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
var southwest = new AV.GeoPoint(30, 115);
var northeast = new AV.GeoPoint(40, 118);
query.withinGeoBox(
  'location',
  southwest,
  northeast
);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

{# withinPolygon is not supported #}

### Caveats about GeoPoints

There are a couple of things to keep in mind:

- Each `{{ baseObjectName }}` may only have one field containing `{{ geoPointObjectName }}` object.
- Points should not exceed the extreme ends of the ranges. Latitude should be between -90.0 and 90.0. Longitude should be between -180.0 and 180.0. Attempting to set latitude or longitude out of bounds will cause an error.
{# - Using the `near` constraint will also limit results to within 100 miles. #}

## Users

At the core of many apps, there is a notion of user accounts that allows users to access their information in a secure manner. We provide a specialized user class called `{{ userObjectName }}` which automatically handles much of the functionality required for user account management in your app.

`{{ userObjectName }}` is a subclass of `{{ baseObjectName }}`. Therefore, all the methods that work for `{{ baseObjectName }}` also work for `{{ userObjectName }}`. The only difference is that `{{ userObjectName }}` has some additional features specific to user accounts. Each app has a dedicated `_User` class for storing `{{ userObjectName }}`.

### User Properties

`{{ userObjectName }}` offers the following fields that `{{ baseObjectName }}` does not have:

- `username`: The username of the user.
- `password`: The password of the user.
- `email`: The email address of the user.
- `emailVerfied`: Whether the user has verified the email address with LeanCloud or not.
- `mobilePhoneNumber`: The mobile phone number of the user.
- `mobilePhoneVerfied`: Whether the user has verified the mobile phone number with LeanCloud or not.

We'll go through each of these in detail as we run through the various use cases for users.

### Signing up

The first thing your app probably will do is to ask the user to sign up. The following code shows a typical sign-up process with username and password:

{% if platform_name === "JavaScript" %}
```js
// Create an instance
var user = new AV.User();

// Same as user.set('username', 'leancloud')
user.setUsername('leancloud');
user.setPassword('P@ssword!');

// Optional
user.setEmail('hey@leancloud.rocks');
user.setMobilePhoneNumber('+11234567890');

// Other fields can be set in the same way as AV.Object
user.set('birthday', new Date('2014-06-01'));
user.set('gender', 'secret');

user.signUp().then(function (user) {
  console.log(user);
  var sessionToken = user.get('sessionToken')
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Create an instance
let user = LCUser()

// Same as user.set("username", value: "leancloud")
user.username = LCString("leancloud")
user.password = LCString("P@ssword!")

// Optional
user.set("email", value: "hey@leancloud.rocks")
user.set("mobilePhoneNumber", value: "+11234567890")

// Other fields can be set in the same way as LCObject
let dateFromString: (String) -> Date? = { string in
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter.date(from: string)
}
user.set("birthday", value: dateFromString("2014-06-01"))
user.set("gender", value: "secret")

user.signUp()
```
{% endif %}
{% if platform_name === "Android" %}
```java
// Create an instance
AVUser user = new AVUser();

// Same as user.put("username", "leancloud")
user.setUsername("leancloud");
user.setPassword("P@ssword!");

// Optional
user.setEmail("hey@leancloud.rocks");
user.setMobilePhoneNumber("+11234567890");

// Other fields can be set in the same way as AVObject
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}
user.put("birthday", getDateWithDateString("2014-06-01"));
user.put("gender", "secret");

user.signUpInBackground(new SignUpCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // User successfully created
        } else {
            // Error handling
        }
    }
});
```
{% endif %}

Note that we used `{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}{% if platform_name === "Android" %}signUpInBackground{% endif %}` instead of `{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Swift" %}save{% endif %}{% if platform_name === "Android" %}saveInBackground{% endif %}`. New `{{ userObjectName }}`s should always be created using the `{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}{% if platform_name === "Android" %}signUpInBackground{% endif %}` method and subsequent updates to a user can be done with `{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Swift" %}save{% endif %}{% if platform_name === "Android" %}saveInBackground{% endif %}`.

{% call docs.noteWrap() %}
If the code returns the error 202, it means that a user with the same `username` already exists in `_User` table and the client should prompt the user to try a different username. It is also required that each `email` or `mobilePhoneNumber` appears only once in the corresponding column, otherwise error 203 or 214 will occur.

You may ask a user to sign up with their email address without an additional username so that the user can directly [reset their password with email](#resetting-passwords). Make sure the **username** field is filled in properly.
{% endcall %}

When creating a user with username and password, the SDK sends the password to the cloud in plaintext through HTTPS and the password will be hashed once it arrives to the cloud. We never store passwords in plaintext, nor will we ever transmit passwords back to the client in plaintext. Our hashing algorithm guarantees that the original password cannot be retrieved by [rainbow table](https://en.wikipedia.org/wiki/Rainbow_table) attack and even app developers themselves will not be able to see the password. Keep in mind that **the password should not be hashed by the client, or the [password reset function](#resetting-passwords) will not work**.

#### Signing up with Phones

Allowing users to sign up with their phone numbers is an easy and secure alternative to asking for usernames and passwords.

There are two basic steps of doing so. First, ask the user to enter a phone number that can receive text messages. When the user clicks on the "Get Verification Code" button, call the `{% if platform_name === "JavaScript" %}AV.Cloud.requestSmsCode{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}AVOSCloud.requestSMSCodeInBackground{% endif %}` function to have a 6-digit verification code sent to the phone number the user just entered:

{% if platform_name === "JavaScript" %}
```js
AV.Cloud.requestSmsCode(
  'MOBILE_PHONE_NUMBER'
).then(function (success) {
  // Verification code is sent successfully
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVOSCloud.requestSMSCodeInBackground(
    "MOBILE_PHONE_NUMBER",
    new RequestMobileCodeCallback() {
        @Override
        public void done(AVException e) {
            if (e == null) {
                // Verification code is sent successfully
            } else {
                // Error handling
            }
        }
    }
);
```
{% endif %}

Next, pass on the verification code entered by the user to the `{% if platform_name === "JavaScript" %}signUpOrlogInWithMobilePhone{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}signUpOrLoginByMobilePhoneInBackground{% endif %}` method:

{% if platform_name === "JavaScript" %}
```js
AV.User.signUpOrlogInWithMobilePhone(
  'MOBILE_PHONE_NUMBER',
  'VERIFICATION_CODE'
).then(function (user) {
  // username and mobilePhoneNumber are the same
  var username          = user.get('username');
  var mobilePhoneNumber = user.get('mobilePhoneNumber');
  var sessionToken      = user.get('sessionToken');
  // password will be a temporary one generated by LeanCloud
}, function (error) {
  // Verification code is incorrect
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.signUpOrLoginByMobilePhoneInBackground(
    "MOBILE_PHONE_NUMBER",
    "VERIFICATION_CODE",
    new LogInCallback<AVUser>() {
        @Override
        public void done(AVUser avUser, AVException e) {
            if (e == null) {
                // username and mobilePhoneNumber are the same
                String username          = avUser.getString('username');
                String mobilePhoneNumber = avUser.getString('mobilePhoneNumber');
                String sessionToken      = avUser.getString('sessionToken');
                // password will be a temporary one generated by LeanCloud
            } else {
                // Verification code is incorrect
            }
        }
    }
);
```
{% endif %}

#### Phone Number Format

A phone number that `{{ userObjectName }}` accepts should have a leading plus sign (+) immediately followed by the country code and the phone number. You should leave out all the dashes, spaces, and other non-numeric characters. For instance, `+8618200008888` is a valid China number (86 is the country code), and `+15555551234` is a valid US or Canada number (1 is the country code, and 555 is the area code).

For a list of countries and regions that LeanCloud can reach out through phones, please refer to the [International SMS](sms-guide.html#international-sms) section in the SMS guide.

### Logging in

The code below logs a user in with username and password:

{% if platform_name === "JavaScript" %}
```js
AV.User.logIn(
  'USERNAME',
  'PASSWORD'
).then(function (loggedInUser) {
  // Logged in successfully
  console.log(loggedInUser);
}, function (error) {
  // Failed to log in
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.logIn(username: "USERNAME", password: "PASSWORD") { result in
    switch result {
    case .success(let user):
        // Logged in successfully
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.logInInBackground(
    "USERNAME",
    "PASSWORD",
    new LogInCallback<AVUser>() {
        @Override
        public void done(AVUser avUser, AVException e) {
            if (e == null) {
                // Logged in successfully
            } else {
                // Failed to log in
            }
        }
    }
);
```
{% endif %}

#### Logging in with Phones

If you are allowing users to sign up with their phone numbers, you can also let them log in with either a password or a verification code via text message. The code below logs a user in with phone number and password:

{% if platform_name === "JavaScript" %}
```js
AV.User.logInWithMobilePhone(
  'MOBILE_PHONE_NUMBER',
  'PASSWORD'
).then(function (loggedInUser) {
  // Logged in successfully
  console.log(loggedInUser);
}, function (error) {
  // Failed to log in
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.logIn(mobilePhoneNumber: "MOBILE_PHONE_NUMBER", password: "PASSWORD") { result in
    switch result {
    case .success(let user):
        // Logged in successfully
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.loginByMobilePhoneNumberInBackground(
    "MOBILE_PHONE_NUMBER",
    "PASSWORD",
    new LogInCallback<AVUser>() {
        @Override
        public void done(AVUser avUser, AVException e) {
            if (e == null) {
                // Logged in successfully
            } else {
                // Failed to log in
            }
        }
    }
);
```
{% endif %}

{% call docs.noteWrap() %}
By default, LeanCloud allows a user to log in to their account as long as the phone number and the password are correct even when the ownership of the phone hasn't been [verified](#verifying-phone-numbers). To make your app more secure, you can choose to allow only those who have their phones verified to log in. The option can be found in [Data > Settings](/dashboard/storage.html?appid={{appid}}#/storage/conf).
{% endcall %}

You may also let a user in with a verification code sent to their phone, which is useful when the user forgets the password and does not want to reset it at the moment. To do so, create a link or a button that says something like "Log in with SMS Verification Code". When a user clicks on it, call the `{% if platform_name === "JavaScript" %}requestLoginSmsCode{% endif %}{% if platform_name === "Swift" %}requestLoginVerificationCode{% endif %}{% if platform_name === "Android" %}requestLoginSmsCodeInBackground{% endif %}` method to send the verification code for the login request:

{% if platform_name === "JavaScript" %}
```js
AV.User.requestLoginSmsCode(
  'MOBILE_PHONE_NUMBER'
).then(function () {
  // Display a message to tell the user that 
  // the verification code is sent
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.requestLoginVerificationCode(mobilePhoneNumber: "MOBILE_PHONE_NUMBER") { result in
    switch result {
    case .success:
        // Display a message to tell the user that 
        // the verification code is sent
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.requestLoginSmsCodeInBackground(
    "MOBILE_PHONE_NUMBER",
    new RequestMobileCodeCallback() {
      @Override
      public void done(AVException e) {
          if (e == null) {
              // Display a message to tell the user that 
              // the verification code is sent
          } else {
              // Error handling
          }
      }
  }
);
```
{% endif %}

After the verification code is entered by the user, call the `{% if platform_name === "JavaScript" %}logInWithMobilePhoneSmsCode{% endif %}{% if platform_name === "Swift" %}logIn{% endif %}{% if platform_name === "Android" %}signUpOrLoginByMobilePhoneInBackground{% endif %}` method to finish logging in:

{% if platform_name === "JavaScript" %}
```js
AV.User.logInWithMobilePhoneSmsCode(
  'MOBILE_PHONE_NUMBER',
  'VERIFICATION_CODE'
).then(function (user) {
  // Logged in successfully
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.logIn(mobilePhoneNumber: "MOBILE_PHONE_NUMBER", verificationCode: "VERIFICATION_CODE") { result in
    switch result {
    case .success(let user):
        // Logged in successfully
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.signUpOrLoginByMobilePhoneInBackground(
    "MOBILE_PHONE_NUMBER",
    "VERIFICATION_CODE",
    new LogInCallback<AVUser>() {
      @Override
      public void done(AVUser avUser, AVException e) {
          if (e == null) {
              // Logged in successfully
          } else {
              // Error handling
          }
      }
  }
);
```
{% endif %}

#### Sandbox Phone Number

During the development of your application, you may need to test the signup or login API intensively with your phone. As there are, however, limits to how quickly messages can be sent into the carrier networks, your testing pace can be greatly affected by such limitations.

To work around it, you can set up a sandbox phone number in [Dashboard > SMS > Settings](/dashboard/messaging.html?appid={{apppid}}#/message/sms/conf). LeanCloud will issue a fixed verification code to go with that sandbox phone number. So whenever LeanCloud detects such combination of data, the user will be let right in authenticated without any connection to the carrier networks being made.

On a related note, a sandbox phone number also comes in handy for iOS apps that allow users to log in with SMS code. This is because Apple may ask developers to provide a phone number and a verification code in order for them to review the app as a normal user. Failing to do so may result in their app being rejected by Apple Store.

For the sending and receiving limitations on SMS messages, please read our [SMS Guide](sms-guide.html) to learn more.

#### Single Device Sign-on

In some scenarios you may want to restrict a user's account to be logged on by no more than one device at a time, that is, when a user logs in to the app on a new device, any previous sessions on other devices will become invalid. Here's the instruction about how you can implement this feature with LeanCloud:

1. Create a new class in the cloud that keeps track of each user's credentials and their device information.
2. Each time when a user logs in on a device, update the device information of this user to be the current device.
3. When the app running on another device is opened, check if the device matches the one stored in the cloud. If it does not, call `{% if platform_name === "JavaScript" %}AV.User.logout{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}AVUser.logOut{% endif %}` to log out.

#### User Account Lockout

If the wrong password or verification code is entered for an account for more than 6 times within 15 minutes, the account will be disabled temporarily and the error `{"code": 1, "error": "You have exceeded the maximum number of login attempts, please try again later, or consider resetting your password."}` will be returned.

The account will be automatically recovered 15 minutes after the last attempt and the process cannot be expedited through SDK or REST API. While the account is disabled, the user cannot be logged in even though the correct credentials are provided. The restriction applies to both SDK and LeanEngine.

### Verifying Emails

You can request that your users have their email addresses verified before they can log in or access certain functions in your app. By doing so it gets harder for spam users to abuse your app. Each time when a user is created or has their email set or changed, the `emailVerified` of this user will be set to **false** in the cloud, and if you enabled **Send verification emails when users register or change email addresses** in [Data > Settings](/dashboard/storage.html?appid={{appid}}#/storage/conf), an email containing a verification link will be sent to this user automatically. You can choose to prevent users with unverified email addresses to log in in the same panel.

If a user forgets to click on the link and needs to have their account verified later, the following code can be used to send a new email:

{% if platform_name === "JavaScript" %}
```js
AV.User.requestEmailVerify(
  'EMAIL_ADDRESS'
).then(function (result) {
  // Verification email is sent successfully
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.requestVerificationMail(email: "EMAIL_ADDRESS") { result in
    switch result {
    case .success:
        // Verification email is sent successfully
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.requestEmailVerifyInBackground(
    "EMAIL_ADDRESS",
    new RequestEmailVerifyCallback() {
        @Override
        public void done(AVException e) {
            if (e == null) {
                // Verification email is sent successfully
            } else {
                // Error handling
            }
        }
    }
);
```
{% endif %}

The `emailVerified` will be set to **true** after the link is clicked on. This field can never be **true** when a user account is first created or when the email is missing.

### Verifying Phone Numbers

Similar to [Verifying Emails](#verifying-emails), you can also request that your users have their phone numbers verified before they can log in or access certain functions in your app. Each time when a user is created or has their phone number set or changed, the `mobilePhoneVerified` of this user will be set to **false** in the cloud, and if you enabled **Send verification SMS when users register or change phone numbers** in [Data > Settings](/dashboard/storage.html?appid={{appid}}#/storage/conf), a text message containing a verification code will be sent to this user automatically. You can choose to prevent users with unverified phone numbers to log in in the same panel.

You can also manually initiate a verification request at anytime with the following code:

{% if platform_name === "JavaScript" %}
```js
AV.User.requestMobilePhoneVerify(
  'MOBILE_PHONE_NUMBER'
).then(function () {
  // Verification code is sent successfully
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

After the verification code is entered by the user, call the `{% if platform_name === "JavaScript" %}verifyMobilePhone{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}{# TODO #}{% endif %}` method and LeanCloud will set the user's `emailVerified` to true:

{% if platform_name === "JavaScript" %}
```js
AV.User.verifyMobilePhone(
  'VERIFICATION_CODE'
).then(function () {
  // mobilePhoneVerified will be set to true
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

{# Enabling phone number verification in an application's settings allows the application to reserve part of its experience for users with confirmed phone numbers. 

Enabling phone number verification can testify that a real person is leveraging the phone in their hand. It stops accounts from being created by bots, and can reduce fraud and associated costs by blocking premium and toll-free numbers.#}

{# ### CAPTCHA Code

Using [CAPTCHA](https://en.wikipedia.org/wiki/CAPTCHA) is a common and effective practice to protest your application from spam and abuse. CAPTCHA offers more than just spam protection. It also helps  reduce fraud and associated costs by blocking bots that could trigger bulk SMS sending.   

LeanCloud CAPTCHA aims to keep bots or other automated software from engaging in abusive activities while letting your valid users pass through with ease.

LeanCloud offers CAPTCHA as a free service to make your app's more bot-proof. #}

### Current User

After a user is logged in, LeanCloud SDK automatically stores the session information of this user in the client so that the user does not need to log in each time they open the client. The following code checks if there is a user logged in:

{% if platform_name === "JavaScript" %}
```js
var currentUser = AV.User.current();
if (currentUser) {
  // Redirect to the home page of your app
}
else {
  // Show the sign-up or log-in page
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let currentUser = LCUser.current {
    // Redirect to the home page of your app
} else {
    // Show the sign-up or log-in page
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser currentUser = AVUser.getCurrentUser();
if (currentUser != null) {
    // Redirect to the home page of your app
} else {
    // Show the sign-up or log-in page
}
```
{% endif %}

The session information of a user will remain in the client until the user is logged out:

{% if platform_name === "JavaScript" %}
```js
AV.User.logOut();
// currentUser becomes null
var currentUser = AV.User.current();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.logOut();
// currentUser becomes null
AVUser currentUser = AVUser.getCurrentUser();
```
{% endif %}

### Setting The Current User

A **session token** will be returned to the client after a user is logged in, which will be cached by our SDK and will be used for authenticating requests made by the same `{{ userObjectName }}` in the future. The session token will be included in the Header of each HTTP request made from the client, which helps the cloud identify the `{{ userObjectName }}` sending the request.

Below are the situations when you may need to log a user in with session token:

- A session token is already cached on the client which can be used to automatically log the user in (you can use `AV.User.current().getSessionToken()` to get the session token of the current user).
- A WebView within the app needs to know the current user.
- The user is logged in on the server side using your own authentication routines and the server is able to provide the session token to the client.

The code below logs a user in with session token:

{% if platform_name === "JavaScript" %}
```js
AV.User.become(
  'SESSION_TOKEN'
).then(function (user) {
  // currentUser has been refreshed
})
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.becomeWithSessionTokenInBackground(
    "SESSION_TOKEN",
    new LogInCallback<AVUser>() {
        @Override
        public void done(AVUser user, AVException e) {
            // currentUser has been refreshed
        }
    }
);
```
{% endif %}

The `{% if platform_name === "JavaScript" %}become{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}becomeWithSessionTokenInBackground{% endif %}` method will ensure the session token is valid before setting the current user.

{% call docs.alertWrap() %}
For security reasons, please avoid passing session token as a part of URL in non-private environments. This increases the risk that they will be captured by attackers.
{% endcall %}

{% call docs.noteWrap() %}
If **Log out the user when password is updated** is checked on in [Data > Settings](/dashboard/storage.html?appid={{appid}}#/storage/conf), the session token of a user will be reset in the cloud after this user changes the password and the client needs to prompt the user to log in again, otherwise [403 (Forbidden)](error_code.html#_403) will be returned as an error.
{% endcall %}

The code below checks if a session token is valid:

{% if platform_name === "JavaScript" %}
```js
var currentUser = AV.User.current();
currentUser.isAuthenticated().then(function (authenticated) {
  // Continue
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.getCurrentUser().isAuthenticated(new AVCallback<Boolean>() {
    @Override
    protected void internalDone0(Boolean aBoolean, AVException e) {
        // Continue
    }
});
```
{% endif %}

### Resetting Passwords

It's quite common for the users of an app to forget their passwords. LeanCloud provides a number of ways for them to reset their passwords.

Here is the flow of resetting password with email:

1. The user enters the email address used for the account.
2. LeanCloud sends an email to the address including a link for resetting password.
3. After the user clicks on the link, a new page will pop up, asking for a new password.
4. The password will be reset after the user enters a new password.

To start with, ask the user to enter the email used for the account, and call the function below:

{% if platform_name === "JavaScript" %}
```js
AV.User.requestPasswordReset(
  'EMAIL_ADDRESS'
).then(function () {
  // Notify the user that password reset request was sent successfully
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.requestPasswordReset(email: "EMAIL_ADDRESS") { result in
    switch result {
    case .success:
        // Notify the user that password reset request was sent successfully
        break
    case .failure(let error):
        // Error handling
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.requestPasswordResetInBackground(
    "EMAIL_ADDRESS",
    new RequestPasswordResetCallback() {
        @Override
        public void done(AVException e) {
            if (e == null) {
                // Notify the user that password reset request was sent successfully
            } else {
                // Error handling
            }
        }
    }
);
```
{% endif %}

The code above will check if there is a user in the `_User` table that has the email provided, and will send them a password reset email if so. As mentioned previously, you can make the username of each user to be the same as their email, or collect the email separately and store it in the email field.

{% call docs.noteWrap() %}
The content of the password reset email is fully customizable. You can go to your app's [Email](/dashboard/app.html?appid={{appid}}#/email) page and modify
the corresponding template.
{% endcall %}

Alternatively, you can ask for the mobile phone number instead of the email to reset their password:

1. The user enters the mobile phone number used for the account.
2. LeanCloud sends a short message to the number including a verification code.
3. The user types in the verification code and a new password.

The code below sends a verification code to a number:

{% if platform_name === "JavaScript" %}
```js
AV.User.requestPasswordResetBySmsCode(
  'MOBILE_PHONE_NUMBER'
).then(function () {
  // SMS code has been sent
}, function (error) {
  // Error handling
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.requestPasswordReset(mobilePhoneNumber: "MOBILE_PHONE_NUMBER") { result in
    switch result {
    case .success:
        // SMS code has been sent
        break
    case .failure(let error):
        // Error handling
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.requestPasswordResetBySmsCodeInBackground(
    "MOBILE_PHONE_NUMBER",
    new RequestMobileCodeCallback() {
        @Override
        public void done(AVException e) {
            if (e == null) {
                // SMS code has been sent
            } else {
                // Error handling
            }
        }
    }
);
```
{% endif %}

LeanCloud will try to match the given phone number with the user's mobilePhoneNumber field, and then send the verification code.

{% call docs.noteWrap() %}
By changing the settings in [Data > Settings](/dashboard/storage.html?appid={{appid}}#/storage/conf), you can restrict the use of the mobile phone number for the above flow only if the mobilePhoneVerified field is true.
{% endcall %}

The code below resets the password of a user after they enter the verification code and a new password:

{% if platform_name === "JavaScript" %}
```js
AV.User.resetPasswordBySmsCode(
  'VERIFICATION_CODE',
  'NEW_PASSWORD'
).then(function () {
  // Password reset is successful
}, function (error) {
  // Wrong verification code entered
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.resetPassword(mobilePhoneNumber: "MOBILE_PHONE_NUMBER", verificationCode: "VERIFICATION_CODE", newPassword: "NEW_PASSWORD") { result in
    switch result {
    case .success:
        // Password reset is successful
        break
    case .failure(let error):
        // Wrong verification code entered
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser.resetPasswordBySmsCodeInBackground(
    "VERIFICATION_CODE",
    "NEW_PASSWORD",
    new UpdatePasswordCallback() {
        @Override
        public void done(AVException e) {
            if (e == null) {
                // Password reset is successful
            } else {
                // Wrong verification code entered
            }
        }
    }
);
```
{% endif %}

{# > Note that the messaging in either of the above flows will reference your app by the name that you specified when you created this app on LeanCloud. #}

{# take a look at our blog article [Customizing password reset and email verification messages](https://blog.leancloud.cn/607/). #}

### Queries on Users

To query for users, you can simple create a new `{{ baseQueryClassName }}` for `{{ userObjectName }}`s:

{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('_User');
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "_User")
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVQuery<AVUser> userQuery = new AVQuery<>("_User");
```
{% endif %}

For security reasons, **the `_User` table of each new app has its `find` permission disabled by default**. Each user can only access their own data in `_User` table and cannot access that of others. If you need to allow each user to view other users' data, we recommend that you create a new table to store such data and enable the `find` permission of this table. You may also encapsulate queries on users within [LeanEngine](leanengine_overview.html) and avoid opening up `find` permissions of `_User` tables.

See [Security of User Objects](#security-of-user-objects) for other restrictions applied to the `_User` table, and [Data and Security](data-security.html) for more information regarding Class-level permission settings.

### Associations

Associations involving `{{ userObjectName }}` works in the same way as basic `{{ baseQueryClassName }}`. The code below saves a new book for an author and retrieves all the books written by that author:

{% if platform_name === "JavaScript" %}
```js
var author = AV.User.current();
var Book   = AV.Object.extend('Book');
var book   = new Book();
book.set('title', 'My Fifth Book');
book.set('author', author);
book.save().then(function (book) {
  // Find all the books by the same user
  var query = new AV.Query(Book);
  query.equalTo('author', author);
  query.find().then(function (books) {
    // All the books
  });
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser author = AVUser.getCurrentUser();
AVObject book = new AVObject("Book");
book.put("title", "My Fifth Book");
book.put("author", author);
book.saveInBackground(new SaveCallback() {
    @Override
    public void done(AVException e) {
        // Find all the books by the same user
        AVQuery<AVObject> query = new AVQuery<>("Book");
        query.whereEqualTo("author", author);
        query.findInBackground(new FindCallback<AVObject>() {
            @Override
            public void done(List<AVObject> list, AVException e) {
                // All the books
            }
        });
    }
});
```
{% endif %}

### Security of User Objects

The `{{ userObjectName }}` class is secured by default. You are not able to invoke any of the save or delete methods unless the `{{ userObjectName }}` was obtained using an authenticated method, like `{% if platform_name === "JavaScript" %}logIn{% endif %}{% if platform_name === "Swift" %}logIn{% endif %}{% if platform_name === "Android" %}logInInBackground{% endif %}` or `{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}{% if platform_name === "Android" %}signUpInBackground{% endif %}`. This ensures that each user can only read or alter their own data.

The reason behind is that most data stored in `{{ userObjectName }}` can be very personal and sensitive, such as mobile phone number, social network account ID, etc. So even the app's owner should avoid tampering with these data for the sake of user's privacy.

The code below illustrates this security policy:

{% if platform_name === "JavaScript" %}
```js
var user = AV.User.logIn(
  'USERNAME',
  'PASSWORD'
).then(function (user) {
  // Attempt to change username
  user.set('username', 'NEW_USERNAME');
  // Password is hashed and an empty string will be returned
  var password = user.get('password');
  // Save changes
  user.save().then(function (user) {
    // This works since the user was authenticated

    // Get the user with a non-authenticated method
    var query = new AV.Query('_User');
    query.get(user.objectId).then(function (userAgain) {
      userAgain.set('username', 'ANOTHER_USERNAME');
      // Save changes
      userAgain.save().then(function () {
      }).catch(function (error) {
        // This will cause error since the AV.User is not authenticated
      });
    });
  });
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

The `{{ userObjectName }}` obtained from `{% if platform_name === "JavaScript" %}AV.User.current(){% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}AVUser.getCurrentUser(){% endif %}` will always be authenticated.

To check if `{{ userObjectName }}` is authenticated, you can invoke the `{% if platform_name === "JavaScript" %}isAuthenticated{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}isAuthenticated{% endif %}` method. You do not need to check if `{{ userObjectName }}` is authenticated if it is obtained via an authenticated method.

As a reminder, the user's password can be set when signing up but cannot be modified and saved to the cloud afterwards unless the user requests it to be [reset](#resetting-passwords). It will not be cached on the client and will show as null when being retrieved from the cloud after the user is logged in.

### Security of Other Objects

For each given object, you can specify which users are allowed to read it and which are allowed to modify it. To support this type of security, each object has an [access control list](http://en.wikipedia.org/wiki/Access_control_list), implemented by the `{% if platform_name === "JavaScript" %}AV.ACL{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}AVACL{% endif %}` class. More details can be found in [ACL Guide](acl-guide.html).

### Linking Users

LeanCloud allows you to link your users with services (commonly known as social networking service, or SNS) like Github, Twitter, Facebook, WeChat, QQ, and Weibo, allowing your users to sign up or log into your application using their existing identities. This is accomplished through the `{% if platform_name === "JavaScript" %}signUpOrlogInWithAuthData{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}loginWithAuthData{% endif %}` method by providing authentication data for the service you wish to link to a user in the `authData` field. Once your user is associated with a service, the `authData` for the service will be stored with the user{# and is retrievable by logging in#}.

For example, to sign up or log in with a user's Weixin (a.k.a. WeChat) account, your code will look like this:

{% if platform_name === "JavaScript" %}
```js
AV.User.signUpOrlogInWithAuthData({
  // Required
  'openid':       'OPEN_ID',
  'access_token': 'ACCESS_TOKEN',
  // Optional
  'expires_in':   '2020-01-06T11:43:11.904Z'
}, 'weixin').then(function (success) {
}, function (error) {
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

LeanCloud then verifies that the provided `authData` is valid and checks to see if a user is already associated with this data. If so, it returns a status code of `200 OK` and the details (including a [`sessionToken`](#setting-the-current-user) for the user).

If the `authData` is not linked to any account, you will instead receive a status code of `201 Created`, indicating that a new user was created. The body of the response will contain the objectId, createdAt, sessionToken, and an automatically-generated unique username. For example:

```json
{
  "username":     "k9mjnl7zq9mjbc7expspsxlls",
  "objectId":     "5b029266fb4ffe005d6c7c2e",
  "createdAt":    "2018-05-21T09:33:26.406Z",
  "updatedAt":    "2018-05-21T09:33:26.575Z",
  "sessionToken": "...",
  // By default authData won't show up here
  // See explanations below
  "authData": {
    ...
  }
  ...
}
```

By default, `authData` cannot be returned to the client by using the `{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Swift" %}Included{% endif %}{% if platform_name === "Android" %}include{% endif %}` or `{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}{% if platform_name === "Android" %}fetchInBackground{% endif %}` method on a query unless the record is owned by the current user. To change this behavior, you can go to your app's [Data](/dashboard/data.html?appid={{appid}}#/_User), select the `_User` class, click on the arrow icon on the authData column header, click on "Edit", and check off the **Restrict read and write permission to the owning user** option so that anyone can have access to it.

To ensure that each `{{ userObjectName }}` is linked with a service account only once, a unique index needs to be created for the `authData.<SERVICE_NAME>.uid` key in the `_User` class.

{# 2019-01-02 Is this relevant? #}
{#
> Please note that out of performance concerns,  you are not permitted to create any new indexes in the Data Browser for a class with more than 10,000 records. However, existing indexes will continue to take effect on records beyond 10K. If your app is on a Business service plan, please [open a support ticket](https://leanticket.cn) with us to have the new index(es) created for you. If using a Developer plan, you must upgrade to a Business plan first.
#}

#### Authentication Data

`authData` is a JSON object with keys for each linked service containing the data below. In each case, you are responsible for completing the authentication flow (usually through OAuth 1.0 or 2.0) to obtain the information from the service provider which is required for linking.

[Sina Weibo](http://open.weibo.com/) authData:

```json
{
  "authData": {
    "weibo": {
      "uid":           "...",
      "access_token":  "...",
      "expiration_in": "..." // Optional
    }
  }
}
```

[Tencent QQ](http://t.qq.com/) authData:

```json
{
  "authData": {
    "qq": {
      "openid":       "...",
      "access_token": "...",
      "expires_in":   "..." // Optional
    }
  }
}
```
[WeChat/WeiXin](http://open.weixin.qq.com/) authData:

```json
{
  "authData": {
    "weixin": {
      "openid":       "...",
      "access_token": "...",
      "expires_in":   "..." // Optional
    }
  }
}
```

LeanCloud automatically validates the integrity of the access token for the services above to prevent data forge attack. When the validation fails, LeanCloud will respond with *"invalid authData"* error and the linking will not be established.

When using other services (such as Github, Twitter, and Facebook) for linking, you are responsible for validating the access token from the service provider. You also need to turn off the **Validate the access token for third-party login** option in your app's [Data > Settings](/dashboard/storage.html?appid={{appid}}#/storage/conf) to let LeanCloud know how to process the authData and handle the linking accordingly.

authData for other services:

```json
{
  "SERVICE_NAME": {
    "uid": "UNIQUE_USER ID_ON_THE_SERVICE_PROVIDERS_PLATFORM",
    "access_token": "ACCESS_TOKEN",
    ...
  }
}
```

#### Unlinking 

`{% if platform_name === "JavaScript" %}signUpOrlogInWithAuthData{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}{% if platform_name === "Android" %}loginWithAuthData{% endif %}` is also used for unlinking by setting the `authData` for the service to `null`. For example, the code below unlinks a user with a Github account:

{% if platform_name === "JavaScript" %}
```js
AV.User.signUpOrlogInWithAuthData(
  null,
  'github'
).then(function () {
  // authData is cleared, user has been unlinked
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
{# TODO #}
```
{% endif %}

### Anonymous Users

With the support of anonymous users, you can have your users try the application without signing up or logging in. The code below created an anonymous user:

{% if platform_name === "JavaScript" %}
```js
AV.User.loginAnonymously().then(user => {
  // Successfully logged in as an anonymous user
}).catch(function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVAnonymousUtils.logIn(new LogInCallback() {
    public void done(T user, AVException e) {
        if (e == null) {
            // Successfully logged in as an anonymous user
        } else {
            // Error handling
        }
    };
});
```
{% endif %}

You can add new properties or fields to an anonymous user just like with a normal user, such as username, password, email, etc. You can also convert an anonymous user to a normal user by going through the same sign-up process as you do with a normal user. An anonymous user can:

- [Sign up with username and password](#signing-up).
- [Link to a third-party service or platform](#linking-users), such as Github.

The code below sets a username and password for an anonymous user:

{% if platform_name === "JavaScript" %}
```js
const currentUser = AV.User.current();
// currentUser is the anonymous user
user.setUsername('USERNAME');
user.setPassword('PASSWORD');

user.signUp().then(user => {
  // User has become a normal user
}).catch(function (error) {
  // Error handling
  console.error(error);
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser currentUser = AVUser.getCurrentUser();
// currentUser is the anonymous user
currentUser.setUsername("USERNAME");
currentUser.setPassword("PASSWORD");

currentUser.signUpInBackground(new SignUpCallback() {
    public void done(AVException e) {
        if (e == null) {
            // User has become a normal user
        } else {
            // Error handling
        }
    }
});
```
{% endif %}

The code below checks if the current user is anonymous:

{% if platform_name === "JavaScript" %}
```js
const currentUser = AV.User.current();
if (currentUser.isAnonymous()) {
  // Show the Sign-up button
} else {
  // Show the Log-out button
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}
{% if platform_name === "Android" %}
```java
AVUser currentUser = AVUser.getCurrentUser();
if (AVAnonymousUtils.isLinked(currentUser)) {
    // Show the Sign-up button
} else {
    // Show the Log-out button
}
```
{% endif %}

If an anonymous user is not converted to a normal user before they log out, they will not be able to log in to the same account later and the data stored in that account cannot be retrieved anymore.

## Roles

As your app grows in scope and user-base, you may find yourself needing more coarse-grained control over access to pieces of your data than user-linked ACLs can provide. To address this requirement, LeanCloud supports a form of Role-based Access Control. Check the detailed [ACL Guide](acl-guide.html) to learn how to set it up for your objects.

## In-App Searching

In-App Searching offers a better way to search through the information contained within your apps. It's built with search engine capabilities that you can easily tap into your app.

Effective and useful app search is crucial for helping app users find what they need. Maximise the value of your app's search features using these principles.

You can use full-text for efficient search capabilities. Text indexes are automatically created for you. Your strings are turned into tokens for fast searching.

Note: Full Text Search can be resource intensive. Ensure the cost of using indexes is worth the benefit.

For more details, see {{inapp_search_guide_url}}.

## In-App Socializing

In-app socializing offers features like following, timeline, status update, interaction, messaging, etc. For more details, see {{status_system_guide_url}}.

{% if platform_name === "JavaScript" %}
## WebView

LeanStorage JavaScript SDK can be used in a WebView like PhoneGap, Cordova, WeChat WebView, etc.

### Android WebView

If you are using Android WebView, the following configurations need to be done when creating WebView in you Native code.

1. Our JS SDK uses window.localStorage which means that localStorage of WebView needs to be enabled:

   ```java
   yourWebView.getSettings().setDomStorageEnabled(true);
   ```

2. If you wish to debug WebView directly in your mobile devices, remote debugging needs to be configured for generating WebView. Refer to [Google's official documentation](https://developer.chrome.com/devtools/docs/remote-debugging) for more details.

   ```java
   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
     yourWebView.setWebContentsDebuggingEnabled(true);
   }
   ```

   Keep in mind that this method is only supported on Android 4.4 and above.
3. When developing the UI of your app with WebView, Native makes use of Hybrid for the app running on your phone. We recommend that you first design the UI of your app with Chrome Developer Tools. After the UI is done, start working on data binding with Native during which you can debug WebView on your phone with Remote debugger. This will save you a lot of time on developing and debugging. If you choose to develop UI with Remote debugger as well, you will end up spending more time on it.
4. As a security practice to prevent JavaScript from calling Java functions for accessing the file system of an Android device, Android 4.2 and later versions only allow WebView to access the methods exposed by the annotation [@JavascriptInterface](http://developer.android.com/reference/android/webkit/JavascriptInterface.html). If you have users using Android 4.2 or above, make sure the annotation is added or **Uncaught TypeError** might be triggered.
{% endif %}
